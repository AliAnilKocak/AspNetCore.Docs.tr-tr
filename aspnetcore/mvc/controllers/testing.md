---
title: "ASP.NET Core test denetleyicisi mantığı"
author: ardalis
description: "Denetleyici mantığında ASP.NET Core Moq ve xUnit test öğrenin."
keywords: "ASP.NET Core, denetleyicisi, test, test, birim testi, birim testi, tümleştirme test, tümleştirme sınaması, xUnit"
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.assetid: dd4135ec-2b15-410c-b3fb-3d12eed4a1ac
ms.technology: aspnet
ms.prod: asp.net-core
uid: mvc/controllers/testing
ms.openlocfilehash: aa60912e06946bd0df4936d33c88d3bf7b69984c
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/10/2017
---
# <a name="testing-controller-logic-in-aspnet-core"></a><span data-ttu-id="88438-104">ASP.NET Core test denetleyicisi mantığı</span><span class="sxs-lookup"><span data-stu-id="88438-104">Testing controller logic in ASP.NET Core</span></span>

<span data-ttu-id="88438-105">Tarafından [Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="88438-105">By [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="88438-106">ASP.NET MVC uygulamalarında denetleyicileri, küçük ve kullanıcı arabirimi sorunları odaklanmıştır olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="88438-106">Controllers in ASP.NET MVC apps should be small and focused on user-interface concerns.</span></span> <span data-ttu-id="88438-107">Kullanıcı Arabirimi sorunları ile ilgili büyük denetleyicileri test ve sürdürmek daha zordur.</span><span class="sxs-lookup"><span data-stu-id="88438-107">Large controllers that deal with non-UI concerns are more difficult to test and maintain.</span></span>

[<span data-ttu-id="88438-108">Görüntülemek veya örnek Github'dan indirin</span><span class="sxs-lookup"><span data-stu-id="88438-108">View or download sample from GitHub</span></span>](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample)

## <a name="testing-controllers"></a><span data-ttu-id="88438-109">Test denetleyicileri</span><span class="sxs-lookup"><span data-stu-id="88438-109">Testing controllers</span></span>

<span data-ttu-id="88438-110">Denetleyicileri herhangi bir ASP.NET Core MVC uygulama merkezi bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="88438-110">Controllers are a central part of any ASP.NET Core MVC application.</span></span> <span data-ttu-id="88438-111">Bu nedenle, uygulamanız için tasarlandığı gibi davranırlar güven olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="88438-111">As such, you should have confidence they behave as intended for your app.</span></span> <span data-ttu-id="88438-112">Otomatikleştirilmiş test üretim düşmeden önce hatalarını algılayabilir ve bu güvenle sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="88438-112">Automated tests can provide you with this confidence and can detect errors before they reach production.</span></span> <span data-ttu-id="88438-113">Denetleyicilerinizi içinde gereksiz sorumlulukları yerleştirmez ve testleri odağınız yalnızca denetleyici sorumlulukları üzerinde sağlamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="88438-113">It's important to avoid placing unnecessary responsibilities within your controllers and ensure your tests focus only on controller responsibilities.</span></span>

<span data-ttu-id="88438-114">Denetleyici mantığında iş mantığı ya da altyapı sorunları üzerinde (örneğin, veri erişimi) odaklı olmayan ve en az olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="88438-114">Controller logic should be minimal and not be focused on business logic or infrastructure concerns (for example, data access).</span></span> <span data-ttu-id="88438-115">Denetleyici mantığında, framework sınayın.</span><span class="sxs-lookup"><span data-stu-id="88438-115">Test controller logic, not the framework.</span></span> <span data-ttu-id="88438-116">Test nasıl denetleyicisi *davranır* geçerli veya geçersiz girişler için temel.</span><span class="sxs-lookup"><span data-stu-id="88438-116">Test how the controller *behaves* based on valid or invalid inputs.</span></span> <span data-ttu-id="88438-117">Denetleyici yanıtları sonucuna göre gerçekleştirdiği iş işlemi sınayın.</span><span class="sxs-lookup"><span data-stu-id="88438-117">Test controller responses based on the result of the business operation it performs.</span></span>

<span data-ttu-id="88438-118">Tipik denetleyicisi sorumlulukları:</span><span class="sxs-lookup"><span data-stu-id="88438-118">Typical controller responsibilities:</span></span>

* <span data-ttu-id="88438-119">Doğrulama `ModelState.IsValid`.</span><span class="sxs-lookup"><span data-stu-id="88438-119">Verify `ModelState.IsValid`.</span></span>
* <span data-ttu-id="88438-120">Bir hata yanıtı döndürür `ModelState` geçersiz.</span><span class="sxs-lookup"><span data-stu-id="88438-120">Return an error response if `ModelState` is invalid.</span></span>
* <span data-ttu-id="88438-121">Bir iş varlığı Kalıcılık alın.</span><span class="sxs-lookup"><span data-stu-id="88438-121">Retrieve a business entity from persistence.</span></span>
* <span data-ttu-id="88438-122">Bir eylem iş varlık üzerinde gerçekleştirin.</span><span class="sxs-lookup"><span data-stu-id="88438-122">Perform an action on the business entity.</span></span>
* <span data-ttu-id="88438-123">İş varlığı için Kalıcılık kaydedin.</span><span class="sxs-lookup"><span data-stu-id="88438-123">Save the business entity to persistence.</span></span>
* <span data-ttu-id="88438-124">Uygun bir dönüş `IActionResult`.</span><span class="sxs-lookup"><span data-stu-id="88438-124">Return an appropriate `IActionResult`.</span></span>

## <a name="unit-testing"></a><span data-ttu-id="88438-125">Birim testi</span><span class="sxs-lookup"><span data-stu-id="88438-125">Unit testing</span></span>

<span data-ttu-id="88438-126">[Birim testi](https://docs.microsoft.com/dotnet/articles/core/testing/unit-testing-with-dotnet-test) haklarında altyapı ve bağımlılıklar ayrı bir parçası olan bir uygulamayı test içerir.</span><span class="sxs-lookup"><span data-stu-id="88438-126">[Unit testing](https://docs.microsoft.com/dotnet/articles/core/testing/unit-testing-with-dotnet-test) involves testing a part of an app in isolation from its infrastructure and dependencies.</span></span> <span data-ttu-id="88438-127">Birim testi denetleyicisi mantığı, yalnızca tek bir eylem'in içeriği ne zaman test, değil davranışı bağımlılıklarından biri veya framework'ün.</span><span class="sxs-lookup"><span data-stu-id="88438-127">When unit testing controller logic, only the contents of a single action is tested, not the behavior of its dependencies or of the framework itself.</span></span> <span data-ttu-id="88438-128">Test denetleyicisi eylemleriniz, birimi, yalnızca davranışını üzerinde odaklanmak emin olun.</span><span class="sxs-lookup"><span data-stu-id="88438-128">As you unit test your controller actions, make sure you focus only on its behavior.</span></span> <span data-ttu-id="88438-129">Denetleyici birim testi gibi şeyleri önler [filtreleri](filters.md), [yönlendirme](../../fundamentals/routing.md), veya [model bağlama](../models/model-binding.md).</span><span class="sxs-lookup"><span data-stu-id="88438-129">A controller unit test avoids things like [filters](filters.md), [routing](../../fundamentals/routing.md), or [model binding](../models/model-binding.md).</span></span> <span data-ttu-id="88438-130">Tek şey test Odaklanıldığında, birim testleri genellikle yazmak basit ve hızlı çalıştırmak.</span><span class="sxs-lookup"><span data-stu-id="88438-130">By focusing on testing just one thing, unit tests are generally simple to write and quick to run.</span></span> <span data-ttu-id="88438-131">Birim testleri iyi yazılmış bir dizi sık kadar ek yükü çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="88438-131">A well-written set of unit tests can be run frequently without much overhead.</span></span> <span data-ttu-id="88438-132">Ancak, birim testleri sorunları algılamaz bileşenleri arasındaki etkileşim içinde olduğu amacı [tümleştirme sınaması](xref:mvc/controllers/testing#integration-testing).</span><span class="sxs-lookup"><span data-stu-id="88438-132">However, unit tests do not detect issues in the interaction between components, which is the purpose of [integration testing](xref:mvc/controllers/testing#integration-testing).</span></span>

<span data-ttu-id="88438-133">Özel Filtreler, yollar, vb., yazıyorsanız, birim testi gereken bunları, ancak belirli denetleyici eylemi sınamalarınızı parçası olarak değil.</span><span class="sxs-lookup"><span data-stu-id="88438-133">If you're writing custom filters, routes, etc, you should unit test them, but not as part of your tests on a particular controller action.</span></span> <span data-ttu-id="88438-134">Bunlar test yalıtım modunda.</span><span class="sxs-lookup"><span data-stu-id="88438-134">They should be tested in isolation.</span></span>

> [!TIP]
> <span data-ttu-id="88438-135">[Oluşturma ve Visual Studio ile birim testleri çalıştırma](https://docs.microsoft.com/visualstudio/test/unit-test-your-code).</span><span class="sxs-lookup"><span data-stu-id="88438-135">[Create and run unit tests with Visual Studio](https://docs.microsoft.com/visualstudio/test/unit-test-your-code).</span></span>

<span data-ttu-id="88438-136">Birim testi göstermek için aşağıdaki denetleyicisiyle gözden geçirin.</span><span class="sxs-lookup"><span data-stu-id="88438-136">To demonstrate unit testing, review the following controller.</span></span> <span data-ttu-id="88438-137">Oturumları fırtınası listesini görüntüler ve yeni bir posta ile oluşturulacak oturumları fırtınası sağlar:</span><span class="sxs-lookup"><span data-stu-id="88438-137">It displays a list of brainstorming sessions and allows new brainstorming sessions to be created with a POST:</span></span>

[!code-csharp[Main](testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/HomeController.cs?highlight=12,16,21,42,43)]

<span data-ttu-id="88438-138">Denetleyici aşağıdaki [açık bağımlılıkları ilkesine](http://deviq.com/explicit-dependencies-principle/), bağımlılık ekleme örneği ile sağlamak için bekleniyor `IBrainstormSessionRepository`.</span><span class="sxs-lookup"><span data-stu-id="88438-138">The controller is following the [explicit dependencies principle](http://deviq.com/explicit-dependencies-principle/), expecting dependency injection to provide it with an instance of `IBrainstormSessionRepository`.</span></span> <span data-ttu-id="88438-139">Bu, oldukça sahte nesne framework gibi kullanarak test kolaylaştırır [Moq](https://www.nuget.org/packages/Moq/).</span><span class="sxs-lookup"><span data-stu-id="88438-139">This makes it fairly easy to test using a mock object framework, like [Moq](https://www.nuget.org/packages/Moq/).</span></span> <span data-ttu-id="88438-140">`HTTP GET Index` Yöntemi hiçbir döngü veya dallanma ve yalnızca çağrıları bir yöntem vardır.</span><span class="sxs-lookup"><span data-stu-id="88438-140">The `HTTP GET Index` method has no looping or branching and only calls one method.</span></span> <span data-ttu-id="88438-141">Bunu test etmek için `Index` yöntemi, ihtiyacımız doğrulamak bir `ViewResult` döndürülür, ile bir `ViewModel` deponun gelen `List` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="88438-141">To test this `Index` method, we need to verify that a `ViewResult` is returned, with a `ViewModel` from the repository's `List` method.</span></span>

[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=17-18&range=1-33,76-95)]

<span data-ttu-id="88438-142">`HomeController` `HTTP POST Index` (Yukarıda gösterilen) yöntemini doğrulayın:</span><span class="sxs-lookup"><span data-stu-id="88438-142">The `HomeController` `HTTP POST Index` method (shown above) should verify:</span></span>

* <span data-ttu-id="88438-143">Hatalı istek eylem yöntemine döndürür `ViewResult` uygun verilerle zaman `ModelState.IsValid` olduğu`false`</span><span class="sxs-lookup"><span data-stu-id="88438-143">The action method returns a Bad Request `ViewResult` with the appropriate data when `ModelState.IsValid` is `false`</span></span>

* <span data-ttu-id="88438-144">`Add` Deposunda yöntemi çağrılır ve bir `RedirectToActionResult` doğru bağımsız değişkenlerle döndürülen zaman `ModelState.IsValid` doğrudur.</span><span class="sxs-lookup"><span data-stu-id="88438-144">The `Add` method on the repository is called and a `RedirectToActionResult` is returned with the correct arguments when `ModelState.IsValid` is true.</span></span>

<span data-ttu-id="88438-145">Geçersiz model durumu kullanarak hataları ekleyerek test edilmiş `AddModelError` ilk testinde aşağıda gösterildiği gibi.</span><span class="sxs-lookup"><span data-stu-id="88438-145">Invalid model state can be tested by adding errors using `AddModelError` as shown in the first test below.</span></span>

[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=8,15-16,37-39&range=35-75)]

<span data-ttu-id="88438-146">İlk test ne zaman onaylar `ModelState` geçerli değil aynı `ViewResult` olarak için döndürülen bir `GET` isteği.</span><span class="sxs-lookup"><span data-stu-id="88438-146">The first test confirms when `ModelState` is not valid, the same `ViewResult` is returned as for a `GET` request.</span></span> <span data-ttu-id="88438-147">Test geçersiz bir modelde geçirmek girişimi değil unutmayın.</span><span class="sxs-lookup"><span data-stu-id="88438-147">Note that the test doesn't attempt to pass in an invalid model.</span></span> <span data-ttu-id="88438-148">Bu olmayacaktır işe yine de model bağlama çalışmadığından bu yana (ancak bir [tümleştirme test](xref:mvc/controllers/testing#integration-testing) alıştırma model bağlama kullanırsınız).</span><span class="sxs-lookup"><span data-stu-id="88438-148">That wouldn't work anyway since model binding isn't running (though an [integration test](xref:mvc/controllers/testing#integration-testing) would use exercise model binding).</span></span> <span data-ttu-id="88438-149">Bu durumda, model bağlama test edilmekte olan değil.</span><span class="sxs-lookup"><span data-stu-id="88438-149">In this case, model binding is not being tested.</span></span> <span data-ttu-id="88438-150">Bu birim testleri eylem yöntemindeki kod yaptığı yalnızca test.</span><span class="sxs-lookup"><span data-stu-id="88438-150">These unit tests are only testing what the code in the action method does.</span></span>

<span data-ttu-id="88438-151">İkinci test olduğunda doğrular `ModelState` geçerli olduğu yeni bir `BrainstormSession` (depo), eklenen ve yöntemi bir `RedirectToActionResult` beklenen özelliklere sahip.</span><span class="sxs-lookup"><span data-stu-id="88438-151">The second test verifies that when `ModelState` is valid, a new `BrainstormSession` is added (via the repository), and the method returns a `RedirectToActionResult` with the expected properties.</span></span> <span data-ttu-id="88438-152">Adlı olmayan mocked çağrıları normalde yoksayılan ancak çağırma `Verifiable` Kurulum sonunda çağrısı testinde doğrulanması izin verir.</span><span class="sxs-lookup"><span data-stu-id="88438-152">Mocked calls that aren't called are normally ignored, but calling `Verifiable` at the end of the setup call allows it to be verified in the test.</span></span> <span data-ttu-id="88438-153">Bu çağrısıyla yapılır `mockRepo.Verify`, hangi başarısız olur test beklenen yöntemi olmayan çağrıldıklarında.</span><span class="sxs-lookup"><span data-stu-id="88438-153">This is done with the call to `mockRepo.Verify`, which will fail the test if the expected method was not called.</span></span>

> [!NOTE]
> <span data-ttu-id="88438-154">Bu örnekte kullanılan Moq kitaplığı doğrulanabilen olmayan mocks ("gevşek" mocks veya yer tutucular olarak da bilinir) ile doğrulanabilir ya da "katı" mocks karışımı kolay hale getirir.</span><span class="sxs-lookup"><span data-stu-id="88438-154">The Moq library used in this sample makes it easy to mix verifiable, or "strict", mocks with non-verifiable mocks (also called "loose" mocks or stubs).</span></span> <span data-ttu-id="88438-155">Daha fazla bilgi edinmek [Moq Mock davranışını özelleştirme](https://github.com/Moq/moq4/wiki/Quickstart#customizing-mock-behavior).</span><span class="sxs-lookup"><span data-stu-id="88438-155">Learn more about [customizing Mock behavior with Moq](https://github.com/Moq/moq4/wiki/Quickstart#customizing-mock-behavior).</span></span>

<span data-ttu-id="88438-156">Uygulama başka bir denetleyici belirli fırtınası oturumuyla ilgili bilgiler görüntüler.</span><span class="sxs-lookup"><span data-stu-id="88438-156">Another controller in the app displays information related to a particular brainstorming session.</span></span> <span data-ttu-id="88438-157">Geçersiz kimlik değerleri ile mücadele etmek için bazı mantığı içerir:</span><span class="sxs-lookup"><span data-stu-id="88438-157">It includes some logic to deal with invalid id values:</span></span>

[!code-csharp[Main](./testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/SessionController.cs?highlight=19,20,21,22,25,26,27,28)]

<span data-ttu-id="88438-158">Denetleyici eylemini sınamak için her üç durumda olan `return` deyimi:</span><span class="sxs-lookup"><span data-stu-id="88438-158">The controller action has three cases to test, one for each `return` statement:</span></span>

[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/SessionControllerTests.cs?highlight=27,28,29,46,47,64,65,66,67,68)]

<span data-ttu-id="88438-159">Uygulama bir web API (fırtınası oturumu ve yeni fikirleri bir oturuma eklemek için bir yöntem ile ilişkili fikirler listesi) işlevselliği sunar:</span><span class="sxs-lookup"><span data-stu-id="88438-159">The app exposes functionality as a web API (a list of ideas associated with a brainstorming session and a method for adding new ideas to a session):</span></span>

<a name="ideas-controller"></a>

[!code-csharp[Main](testing/sample/TestingControllersSample/src/TestingControllersSample/Api/IdeasController.cs?highlight=21,22,27,30,31,32,33,34,35,36,41,42,46,52,65)]

<span data-ttu-id="88438-160">`ForSession` Yöntemi listesini döndürür `IdeaDTO` türleri.</span><span class="sxs-lookup"><span data-stu-id="88438-160">The `ForSession` method returns a list of `IdeaDTO` types.</span></span> <span data-ttu-id="88438-161">Doğrudan API çağrıları, iş etki alanı varlık döndüren kaçınmak için API İstemci gerektirir ve bunlar gereksiz yere, uygulamanızın iç etki alanı modeli dışarıdan kullanıma API'si ile eşleştiği daha fazla veri itibaren sık içerirler.</span><span class="sxs-lookup"><span data-stu-id="88438-161">Avoid returning your business domain entities directly via API calls, since frequently they include more data than the API client requires, and they unnecessarily couple your app's internal domain model with the API you expose externally.</span></span> <span data-ttu-id="88438-162">Etki alanı varlıkları ve kablo üzerinden döndürecektir türleri arasında eşleme el ile yapılabilir (LINQ kullanarak `Select` aşağıda gösterildiği gibi) veya benzer bir kitaplık kullanılarak [AutoMapper](https://github.com/AutoMapper/AutoMapper)</span><span class="sxs-lookup"><span data-stu-id="88438-162">Mapping between domain entities and the types you will return over the wire can be done manually (using a LINQ `Select` as shown here) or using a library like [AutoMapper](https://github.com/AutoMapper/AutoMapper)</span></span>

<span data-ttu-id="88438-163">Birim testleri için `Create` ve `ForSession` API yöntemlerini:</span><span class="sxs-lookup"><span data-stu-id="88438-163">The unit tests for the `Create` and `ForSession` API methods:</span></span>

[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/ApiIdeasControllerTests.cs?highlight=18,23,29,33,38-39,43,50,58-59,68-70,76-78&range=1-83,121-135)]

<span data-ttu-id="88438-164">Yöntem davranışını test etmek için daha önce belirtildiği gibi `ModelState` geçersiz model hatası denetleyiciye testin bir parçası ekleyin.</span><span class="sxs-lookup"><span data-stu-id="88438-164">As stated previously, to test the behavior of the method when `ModelState` is invalid, add a model error to the controller as part of the test.</span></span> <span data-ttu-id="88438-165">Model doğrulama veya model bağlama, birim testleri test-yalnızca belirli bir ile karşılaşıldığında, eylem yönteminin davranışı test denemeyin `ModelState` değeri.</span><span class="sxs-lookup"><span data-stu-id="88438-165">Don't try to test model validation or model binding in your unit tests - just test your action method's behavior when confronted with a particular `ModelState` value.</span></span>

<span data-ttu-id="88438-166">İkinci test sahte depo null döndürmek için yapılandırılmış şekilde null döndüren depo bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="88438-166">The second test depends on the repository returning null, so the mock repository is configured to return null.</span></span> <span data-ttu-id="88438-167">Bir test veritabanı oluşturmak için gerek yoktur (bellekte veya aksi halde) ve bu sonuç döndüren bir sorgu oluşturun -, tek bir deyimde gösterildiği gibi yapılabilir.</span><span class="sxs-lookup"><span data-stu-id="88438-167">There's no need to create a test database (in memory or otherwise) and construct a query that will return this result - it can be done in a single statement as shown.</span></span>

<span data-ttu-id="88438-168">Son test doğrular deponun `Update` yöntemi çağrılır.</span><span class="sxs-lookup"><span data-stu-id="88438-168">The last test verifies that the repository's `Update` method is called.</span></span> <span data-ttu-id="88438-169">Daha önce yaptığımız gibi mock ile çağrılır `Verifiable` ve ardından mocked deponun `Verify` yöntemi doğrulanabilen yöntemi yürütüldü onaylamak için çağrılır.</span><span class="sxs-lookup"><span data-stu-id="88438-169">As we did previously, the mock is called with `Verifiable` and then the mocked repository's `Verify` method is called to confirm the verifiable method was executed.</span></span> <span data-ttu-id="88438-170">Emin olmak için bir birim testi sorumluluğu değil `Update` yöntemi kaydedilen veri; tümleştirme test ile yapılabilir.</span><span class="sxs-lookup"><span data-stu-id="88438-170">It's not a unit test responsibility to ensure that the `Update` method saved the data; that can be done with an integration test.</span></span>

## <a name="integration-testing"></a><span data-ttu-id="88438-171">Tümleştirme sınaması</span><span class="sxs-lookup"><span data-stu-id="88438-171">Integration testing</span></span>

<span data-ttu-id="88438-172">[Tümleştirme sınaması](../../testing/integration-testing.md) uygulama iş içindeki ayrı modülleri doğru birlikte emin olmak için gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="88438-172">[Integration testing](../../testing/integration-testing.md) is done to ensure separate modules within your app work correctly together.</span></span> <span data-ttu-id="88438-173">Genellikle, herhangi bir şey birim testi ile test ile tümleştirme test ayrıca test edebilirsiniz, ancak tersi doğru değil.</span><span class="sxs-lookup"><span data-stu-id="88438-173">Generally, anything you can test with a unit test, you can also test with an integration test, but the reverse isn't true.</span></span> <span data-ttu-id="88438-174">Ancak, tümleştirme testleri birim testleri çok daha yavaş olma eğilimindedir.</span><span class="sxs-lookup"><span data-stu-id="88438-174">However, integration tests tend to be much slower than unit tests.</span></span> <span data-ttu-id="88438-175">Bu nedenle, ne olursa olsun da ile birim testleri ve birden çok ortak çalışanlar gerektiren senaryolar için tümleştirme testleri kullanın test etmek en iyisidir.</span><span class="sxs-lookup"><span data-stu-id="88438-175">Thus, it's best to test whatever you can with unit tests, and use integration tests for scenarios that involve multiple collaborators.</span></span>

<span data-ttu-id="88438-176">Bunlar hala yararlı olabilir ancak sahte nesneler tümleştirme testlerinde nadiren kullanılır.</span><span class="sxs-lookup"><span data-stu-id="88438-176">Although they may still be useful, mock objects are rarely used in integration tests.</span></span> <span data-ttu-id="88438-177">Birim testi sınanan birim dışında ortak test amaçları doğrultusunda nasıl hareket etmesi gerektiğini denetlemek için etkili bir yol sahte nesneleridir.</span><span class="sxs-lookup"><span data-stu-id="88438-177">In unit testing, mock objects are an effective way to control how collaborators outside of the unit being tested should behave for the purposes of the test.</span></span> <span data-ttu-id="88438-178">Bir tümleştirme testinde gerçek ortak çalışanlar, tüm alt sistemi birlikte düzgün çalıştığını doğrulamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="88438-178">In an integration test, real collaborators are used to confirm the whole subsystem works together correctly.</span></span>

### <a name="application-state"></a><span data-ttu-id="88438-179">Uygulama durumu</span><span class="sxs-lookup"><span data-stu-id="88438-179">Application state</span></span>

<span data-ttu-id="88438-180">Tümleştirme sınaması gerçekleştirirken bir önemli uygulamanızın durumunun nasıl ayarlanacağı konudur.</span><span class="sxs-lookup"><span data-stu-id="88438-180">One important consideration when performing integration testing is how to set your app's state.</span></span> <span data-ttu-id="88438-181">Testleri birbirlerinden bağımsız çalıştırmanız gerekir ve böylece her test bilinen bir duruma uygulamada ile başlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="88438-181">Tests need to run independent of one another, and so each test should start with the app in a known state.</span></span> <span data-ttu-id="88438-182">Uygulamanızı değil veya bir veritabanını kullanmak herhangi Kalıcılık varsa, bu bir sorun olabilir.</span><span class="sxs-lookup"><span data-stu-id="88438-182">If your app doesn't use a database or have any persistence, this may not be an issue.</span></span> <span data-ttu-id="88438-183">Ancak, veri deposunu sıfırlama sürece bir test tarafından yapılan değişiklikler başka bir test etkileyebilir şekilde durumlarına bazı tür bir veri deposu, çoğu gerçek uygulamalar kalıcı olmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="88438-183">However, most real-world apps persist their state to some kind of data store, so any modifications made by one test could impact another test unless the data store is reset.</span></span> <span data-ttu-id="88438-184">Yerleşik kullanarak `TestServer`bizim tümleştirme testleri içindeki konak ASP.NET Core uygulamaları çok basit ancak, değil mutlaka erişimi izni verin, kullanacağınız veri.</span><span class="sxs-lookup"><span data-stu-id="88438-184">Using the built-in `TestServer`, it's very straightforward to host ASP.NET Core apps within our integration tests, but that doesn't necessarily grant access to the data it will use.</span></span> <span data-ttu-id="88438-185">Gerçek bir veritabanı kullanıyorsanız, bir test veritabanına bağlanan uygulamanız için bir yaklaşım ise her test yürütülmeden önce testlerinizi erişmek ve sağlamak için bilinen bir duruma sıfırlanır.</span><span class="sxs-lookup"><span data-stu-id="88438-185">If you're using an actual database, one approach is to have the app connect to a test database, which your tests can access and ensure is reset to a known state before each test executes.</span></span>

<span data-ttu-id="88438-186">Yalnızca kendisine my test projesinden bağlanamıyorum şekilde bu örnek uygulamasında Entity Framework Çekirdek'ın InMemoryDatabase destek kullanıyorum.</span><span class="sxs-lookup"><span data-stu-id="88438-186">In this sample application, I'm using Entity Framework Core's InMemoryDatabase support, so I can't just connect to it from my test project.</span></span> <span data-ttu-id="88438-187">Bunun yerine, ı kullanıma bir `InitializeDatabase` uygulamanın yönteminden `Startup` bu ise, uygulama başlatıldığında ı çağrı sınıfını `Development` ortamı.</span><span class="sxs-lookup"><span data-stu-id="88438-187">Instead, I expose an `InitializeDatabase` method from the app's `Startup` class, which I call when the app starts up if it's in the `Development` environment.</span></span> <span data-ttu-id="88438-188">Bunlar ortam kümesine sürece my tümleştirme testleri otomatik olarak bu yararlı `Development`.</span><span class="sxs-lookup"><span data-stu-id="88438-188">My integration tests automatically benefit from this as long as they set the environment to `Development`.</span></span> <span data-ttu-id="88438-189">Veritabanı, uygulama her başladığında InMemoryDatabase sıfırlama beri sıfırlama hakkında endişelenmeniz gerekmez.</span><span class="sxs-lookup"><span data-stu-id="88438-189">I don't have to worry about resetting the database, since the InMemoryDatabase is reset each time the app restarts.</span></span>

<span data-ttu-id="88438-190">`Startup` Sınıfı:</span><span class="sxs-lookup"><span data-stu-id="88438-190">The `Startup` class:</span></span>

[!code-csharp[Main](testing/sample/TestingControllersSample/src/TestingControllersSample/Startup.cs?highlight=19,20,34,35,43,52)]

<span data-ttu-id="88438-191">Göreceğiniz `GetTestSession` tümleştirme testlerinde sık kullanılan yöntem.</span><span class="sxs-lookup"><span data-stu-id="88438-191">You'll see the `GetTestSession` method used frequently in the integration tests below.</span></span>

### <a name="accessing-views"></a><span data-ttu-id="88438-192">Görünümleri erişme</span><span class="sxs-lookup"><span data-stu-id="88438-192">Accessing views</span></span>

<span data-ttu-id="88438-193">Her tümleştirme test sınıfı yapılandırır `TestServer` ASP.NET Core uygulama çalışır.</span><span class="sxs-lookup"><span data-stu-id="88438-193">Each integration test class configures the `TestServer` that will run the ASP.NET Core app.</span></span> <span data-ttu-id="88438-194">Varsayılan olarak, `TestServer` onu çalıştırdığı - bu durumda, test proje klasöründen klasör web uygulamasında barındırır.</span><span class="sxs-lookup"><span data-stu-id="88438-194">By default, `TestServer` hosts the web app in the folder where it's running - in this case, the test project folder.</span></span> <span data-ttu-id="88438-195">Bu nedenle, çalıştığınızda dönüş denetleyici eylemleri test etmek `ViewResult`, bu hatayı görebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="88438-195">Thus, when you attempt to test controller actions that return `ViewResult`, you may see this error:</span></span>

```
The view 'Index' was not found. The following locations were searched:
(list of locations)
```

<span data-ttu-id="88438-196">Bu sorunu gidermek için test projesi için görünümleri gidebilecektir sunucunun içerik kök yapılandırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="88438-196">To correct this issue, you need to configure the server's content root, so it can locate the views for the project being tested.</span></span> <span data-ttu-id="88438-197">Bu çağrısıyla yapılır `UseContentRoot` içinde `TestFixture` sınıfı, aşağıda gösterilmektedir:</span><span class="sxs-lookup"><span data-stu-id="88438-197">This is done by a call to `UseContentRoot` in the `TestFixture` class, shown below:</span></span>

[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/TestFixture.cs?highlight=30,33)]

<span data-ttu-id="88438-198">`TestFixture` Sınıfı, yapılandırma ve oluşturma sorumlu `TestServer`, ayarlanırken bir `HttpClient` ile iletişim kurmak için `TestServer`.</span><span class="sxs-lookup"><span data-stu-id="88438-198">The `TestFixture` class is responsible for configuring and creating the `TestServer`, setting up an `HttpClient` to communicate with the `TestServer`.</span></span> <span data-ttu-id="88438-199">Her tümleştirme kullanır testleri `Client` özelliğini test sunucusuna bağlanmak ve bir istekte bulunun.</span><span class="sxs-lookup"><span data-stu-id="88438-199">Each of the integration tests uses the `Client` property to connect to the test server and make a request.</span></span>

[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/HomeControllerTests.cs?highlight=20,26,29,30,31,35,38,39,40,41,44,47,48)]

<span data-ttu-id="88438-200">Yukarıdaki ilk testinde `responseString` gerçek işlenen HTML beklenen sonuçları içerdiği onaylamak için Denetlenmekte görünümünden tutar.</span><span class="sxs-lookup"><span data-stu-id="88438-200">In the first test above, the `responseString` holds the actual rendered HTML from the View, which can be inspected to confirm it contains expected results.</span></span>

<span data-ttu-id="88438-201">İkinci test benzersiz oturum adı ile bir form POST oluşturur ve uygulamaya gönderir, ardından beklenen yeniden yönlendirme döndürülür doğrular.</span><span class="sxs-lookup"><span data-stu-id="88438-201">The second test constructs a form POST with a unique session name and POSTs it to the app, then verifies that the expected redirect is returned.</span></span>

### <a name="api-methods"></a><span data-ttu-id="88438-202">API yöntemlerini</span><span class="sxs-lookup"><span data-stu-id="88438-202">API methods</span></span>

<span data-ttu-id="88438-203">Uygulamanızı web API'leri, buna ait otomatikleştirilmiş testleri için iyi bir fikir onaylayın bunlar yürütme beklendiği gibi göstermiyorsa.</span><span class="sxs-lookup"><span data-stu-id="88438-203">If your app exposes web APIs, it's a good idea to have automated tests confirm they execute as expected.</span></span> <span data-ttu-id="88438-204">Yerleşik `TestServer` web API'leri test kolay hale getirir.</span><span class="sxs-lookup"><span data-stu-id="88438-204">The built-in `TestServer` makes it easy to test web APIs.</span></span> <span data-ttu-id="88438-205">Model bağlama, API yöntemlerini kullanıyorsanız, her zaman denetlemelisiniz `ModelState.IsValid`, ve tümleştirme testleri, model doğrulama düzgün çalıştığını doğrulamak için doğru yerde.</span><span class="sxs-lookup"><span data-stu-id="88438-205">If your API methods are using model binding, you should always check `ModelState.IsValid`, and integration tests are the right place to confirm that your model validation is working properly.</span></span>

<span data-ttu-id="88438-206">Testleri hedef aşağıdaki kümesini `Create` yönteminde [IdeasController](xref:mvc/controllers/testing#ideas-controller) yukarıda gösterilen sınıfı:</span><span class="sxs-lookup"><span data-stu-id="88438-206">The following set of tests target the `Create` method in the [IdeasController](xref:mvc/controllers/testing#ideas-controller) class shown above:</span></span>

[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/ApiIdeasControllerTests.cs)]

<span data-ttu-id="88438-207">HTML görünümleri döndüren eylem tümleştirme testlerin aksine, son test yukarıda gösterildiği gibi sonuçları döndüren web API yöntemleri genellikle güçlü şekilde yazılan nesnelerin seri durumdan çıkarılmış olabilir.</span><span class="sxs-lookup"><span data-stu-id="88438-207">Unlike integration tests of actions that returns HTML views, web API methods that return results can usually be deserialized as strongly typed objects, as the last test above shows.</span></span> <span data-ttu-id="88438-208">Bu durumda, test sonucu çıkarır bir `BrainstormSession` örneği ve fikir fikirleri kendi koleksiyonuna doğru eklendiğini doğrular.</span><span class="sxs-lookup"><span data-stu-id="88438-208">In this case, the test deserializes the result to a `BrainstormSession` instance, and confirms that the idea was correctly added to its collection of ideas.</span></span>

<span data-ttu-id="88438-209">Bu makalede 's tümleştirme testleri ek örnekler bulacaksınız [örnek proje](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample).</span><span class="sxs-lookup"><span data-stu-id="88438-209">You'll find additional examples of integration tests in this article's [sample project](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample).</span></span>
