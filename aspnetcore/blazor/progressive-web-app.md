---
title: ASP.NET Core Blazor WebAssembly ile Aşamalı Web Uygulamaları Oluşturun
author: guardrex
description: Masaüstü uygulaması gibi Blazorgörünen modern tarayıcı özelliklerini kullanan aşamalı web uygulamasını (PWA) nasıl oluştureceğinizi öğrenin.
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc
ms.date: 03/23/2020
no-loc:
- Blazor
- SignalR
uid: blazor/progressive-web-app
ms.openlocfilehash: fe69e51aefae9c80e5bb4b78151d384ce25d41a7
ms.sourcegitcommit: f7886fd2e219db9d7ce27b16c0dc5901e658d64e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/06/2020
ms.locfileid: "80218953"
---
# <a name="build-progressive-web-applications-with-aspnet-core-blazor-webassembly"></a><span data-ttu-id="03c6e-103">Core Blazor WebAssembly ile ASP.NET Aşamalı Web Uygulamaları Oluşturun</span><span class="sxs-lookup"><span data-stu-id="03c6e-103">Build Progressive Web Applications with ASP.NET Core Blazor WebAssembly</span></span>

<span data-ttu-id="03c6e-104">Yazar: [Steve Sanderson](https://github.com/SteveSandersonMS)</span><span class="sxs-lookup"><span data-stu-id="03c6e-104">By [Steve Sanderson](https://github.com/SteveSandersonMS)</span></span>

[!INCLUDE[](~/includes/blazorwasm-preview-notice.md)]

[!INCLUDE[](~/includes/blazorwasm-3.2-template-article-notice.md)]

<span data-ttu-id="03c6e-105">Aşamalı Web Uygulaması (PWA), modern tarayıcı API'lerini ve yeteneklerini bir masaüstü uygulaması gibi kullanabilen tek sayfalık bir uygulamadır (SPA).</span><span class="sxs-lookup"><span data-stu-id="03c6e-105">A Progressive Web Application (PWA) is a Single Page Application (SPA) that uses modern browser APIs and capabilities to behave like a desktop app.</span></span> <span data-ttu-id="03c6e-106">Blazor WebAssembly standart tabanlı istemci tarafı web uygulaması platformudur, bu nedenle aşağıdaki özellikler için gerekli PWA API'leri de dahil olmak üzere herhangi bir tarayıcı API'sini kullanabilir:</span><span class="sxs-lookup"><span data-stu-id="03c6e-106">Blazor WebAssembly is a standards-based client-side web app platform, so it can use any browser API, including PWA APIs required for the following capabilities:</span></span>

* <span data-ttu-id="03c6e-107">Ağ hızından bağımsız olarak çevrimdışı çalışma ve anında yükleme.</span><span class="sxs-lookup"><span data-stu-id="03c6e-107">Working offline and loading instantly, independent of network speed.</span></span>
* <span data-ttu-id="03c6e-108">Sadece bir tarayıcı penceresinde değil, kendi uygulama penceresinde çalışan.</span><span class="sxs-lookup"><span data-stu-id="03c6e-108">Running in its own app window, not just a browser window.</span></span>
* <span data-ttu-id="03c6e-109">Ana bilgisayar işletim sistemi başlat menüsünden, dock veya ana ekrandan başlatılan ediliyor.</span><span class="sxs-lookup"><span data-stu-id="03c6e-109">Being launched from the host's operating system start menu, dock, or home screen.</span></span>
* <span data-ttu-id="03c6e-110">Kullanıcı uygulamayı kullanmasa bile arka uçtan anında iletme bildirimleri alma.</span><span class="sxs-lookup"><span data-stu-id="03c6e-110">Receiving push notifications from a backend server, even while the user isn't using the app.</span></span>
* <span data-ttu-id="03c6e-111">Arka planda otomatik olarak güncelleniyor.</span><span class="sxs-lookup"><span data-stu-id="03c6e-111">Automatically updating in the background.</span></span>

<span data-ttu-id="03c6e-112">Aşamalı *sözcük* bu tür uygulamaları tanımlamak için kullanılır, çünkü:</span><span class="sxs-lookup"><span data-stu-id="03c6e-112">The word *progressive* is used to describe such apps because:</span></span>

* <span data-ttu-id="03c6e-113">Bir kullanıcı uygulamayı ilk olarak diğer SPA'lar gibi web tarayıcısı içinde keşfedebilir ve kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-113">A user might first discover and use the app within their web browser like any other SPA.</span></span>
* <span data-ttu-id="03c6e-114">Daha sonra, kullanıcı işletim sistemi yüklemeve anında iletme bildirimleri etkinleştirme ile ilerler.</span><span class="sxs-lookup"><span data-stu-id="03c6e-114">Later, the user progresses to installing it in their OS and enabling push notifications.</span></span>

## <a name="create-a-project-from-the-pwa-template"></a><span data-ttu-id="03c6e-115">PWA şablonundan proje oluşturma</span><span class="sxs-lookup"><span data-stu-id="03c6e-115">Create a project from the PWA template</span></span>

# <a name="visual-studio"></a>[<span data-ttu-id="03c6e-116">Visual Studio</span><span class="sxs-lookup"><span data-stu-id="03c6e-116">Visual Studio</span></span>](#tab/visual-studio)

<span data-ttu-id="03c6e-117">**Yeni Proje Oluştur** iletişim kutusunda yeni bir **Blazor WebAssembly Uygulaması** oluştururken, İlerleme Web **Uygulaması** onay kutusunu seçin:</span><span class="sxs-lookup"><span data-stu-id="03c6e-117">When creating a new **Blazor WebAssembly App** in the **Create a New Project** dialog, select the **Progress Web Application** check box:</span></span>

![Visual Studio yeni proje iletişim kutusunda 'Aşamalı Web Uygulaması' onay kutusu seçilir.](progressive-web-app/_static/image1.png)

<!--

# [Visual Studio for Mac](#tab/visual-studio-mac)

-->

# <a name="visual-studio-code--net-core-cli"></a>[<span data-ttu-id="03c6e-119">Görsel Stüdyo Kodu / .NET Çekirdek CLI</span><span class="sxs-lookup"><span data-stu-id="03c6e-119">Visual Studio Code / .NET Core CLI</span></span>](#tab/visual-studio-code+netcore-cli)

<span data-ttu-id="03c6e-120">`--pwa` Anahtarla komut kabuğunda bir PWA projesi oluşturun:</span><span class="sxs-lookup"><span data-stu-id="03c6e-120">Create a PWA project in a command shell with the `--pwa` switch:</span></span>

```dotnetcli
dotnet new blazorwasm -o MyNewProject --pwa
```

---

<span data-ttu-id="03c6e-121">İsteğe bağlı olarak, PWA ASP.NET Core Hosted şablonundan oluşturulan bir uygulama için yapılandırılabilir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-121">Optionally, PWA can be configured for an app created from the ASP.NET Core Hosted template.</span></span> <span data-ttu-id="03c6e-122">PWA senaryosu barındırma modelinden bağımsızdır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-122">The PWA scenario is independent of the hosting model.</span></span>

## <a name="installation-and-app-manifest"></a><span data-ttu-id="03c6e-123">Kurulum ve uygulama bildirimi</span><span class="sxs-lookup"><span data-stu-id="03c6e-123">Installation and app manifest</span></span>

<span data-ttu-id="03c6e-124">PWA şablonu kullanılarak oluşturulan bir uygulamayı ziyaret ederken, kullanıcılar uygulamayı işletim sistemi başlangıç menüsüne, dock'una veya ana ekranına yükleme seçeneğine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-124">When visiting an app created using the PWA template, users have the option of installing the app into their OS's start menu, dock, or home screen.</span></span> <span data-ttu-id="03c6e-125">Bu seçeneğin sunulma şekli kullanıcının tarayıcıya bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-125">The way this option is presented depends on the user's browser.</span></span> <span data-ttu-id="03c6e-126">Edge veya Chrome gibi masaüstü Krom tabanlı tarayıcıları kullanırken, URL çubuğunda **Ekle** düğmesi görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-126">When using desktop Chromium-based browsers, such as Edge or Chrome, an **Add** button appears within the URL bar.</span></span> <span data-ttu-id="03c6e-127">Kullanıcı **Ekle** düğmesini seçtikten sonra bir onay iletişim kutusu alır:</span><span class="sxs-lookup"><span data-stu-id="03c6e-127">After the user selects the **Add** button, they receive a confirmation dialog:</span></span>

![Google Chrome'daki onay diaglogu, 'MyBlazorPwa' uygulaması için kullanıcıya bir Yükle düğmesi sunar.](progressive-web-app/_static/image2.png)

<span data-ttu-id="03c6e-129">iOS'ta ziyaretçiler, PWA'yı Safari'nin **Paylaş** düğmesini ve **Ana Ekrana Ekle** seçeneğini kullanarak yükleyebilir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-129">On iOS, visitors can install the PWA using Safari's **Share** button and its **Add to Homescreen** option.</span></span> <span data-ttu-id="03c6e-130">Android için Chrome'da, kullanıcılar sağ üst köşedeki **Menü** düğmesini seçerek **Ana Ekrana Ekle'yi**seçmelidir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-130">On Chrome for Android, users should select the **Menu** button in the upper-right corner, followed by **Add to Home screen**.</span></span>

<span data-ttu-id="03c6e-131">Yüklendikten sonra, uygulama adres çubuğu olmadan kendi penceresinde görünür:</span><span class="sxs-lookup"><span data-stu-id="03c6e-131">Once installed, the app appears in its own window without an address bar:</span></span>

!['MyBlazorPwa' uygulaması, adres çubuğu olmadan Google Chrome'da çalışır.](progressive-web-app/_static/image3.png)

<span data-ttu-id="03c6e-133">Pencerenin başlığını, renk düzenini, simgesini veya diğer ayrıntıları özelleştirmek için projenin *wwwroot* dizinindeki *manifest.json* dosyasına bakın.</span><span class="sxs-lookup"><span data-stu-id="03c6e-133">To customize the window's title, color scheme, icon, or other details, see the *manifest.json* file in the project's *wwwroot* directory.</span></span> <span data-ttu-id="03c6e-134">Bu dosyanın şeması web standartlarına göre tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-134">The schema of this file is defined by web standards.</span></span> <span data-ttu-id="03c6e-135">Daha fazla bilgi için [MDN web dokümanlarına bakın: Web App Manifest.](https://developer.mozilla.org/docs/Web/Manifest)</span><span class="sxs-lookup"><span data-stu-id="03c6e-135">For more information, see [MDN web docs: Web App Manifest](https://developer.mozilla.org/docs/Web/Manifest).</span></span>

## <a name="offline-support"></a><span data-ttu-id="03c6e-136">Çevrimdışı destek</span><span class="sxs-lookup"><span data-stu-id="03c6e-136">Offline support</span></span>

<span data-ttu-id="03c6e-137">Varsayılan olarak, PWA şablonu seçeneği kullanılarak oluşturulan uygulamaların çevrimdışı çalıştırmak için desteği olur.</span><span class="sxs-lookup"><span data-stu-id="03c6e-137">By default, apps created using the PWA template option have support for running offline.</span></span> <span data-ttu-id="03c6e-138">Bir kullanıcının ilk olarak uygulamayı çevrimiçi yken ziyaret etmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-138">A user must first visit the app while they're online.</span></span> <span data-ttu-id="03c6e-139">Tarayıcı çevrimdışı çalıştırmak için gereken tüm kaynakları otomatik olarak karşıdan yükler ve önbelleğe aler.</span><span class="sxs-lookup"><span data-stu-id="03c6e-139">The browser automatically downloads and caches all of the resources required to operate offline.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="03c6e-140">Geliştirme desteği, değişiklikler yapma ve bunları test etme olağan geliştirme döngüsünü engelleyecektir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-140">Development support would interfere with the usual development cycle of making changes and testing them.</span></span> <span data-ttu-id="03c6e-141">Bu nedenle, çevrimdışı destek yalnızca yayınlanan uygulamalar için *etkinleştirilir.*</span><span class="sxs-lookup"><span data-stu-id="03c6e-141">Therefore, offline support is only enabled for *published* apps.</span></span> 

> [!WARNING]
> <span data-ttu-id="03c6e-142">Çevrimdışı olarak etkin bir PWA dağıtmayı planlıyorsanız, [birkaç önemli uyarı ve uyarı](#caveats-for-offline-pwas)vardır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-142">If you intend to distribute an offline-enabled PWA, there are [several important warnings and caveats](#caveats-for-offline-pwas).</span></span> <span data-ttu-id="03c6e-143">Bu senaryolar çevrimdışı PWA'lara özgüdir Blazorve özel değildir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-143">These scenarios are inherent to offline PWAs and not specific to Blazor.</span></span> <span data-ttu-id="03c6e-144">Çevrimdışı özellikli uygulamanızın nasıl çalışacağı hakkında varsayımlarda bulunmadan önce bu uyarıları okuduğunuzdan ve anladığınızdan emin olun.</span><span class="sxs-lookup"><span data-stu-id="03c6e-144">Be sure to read and understand these caveats before making assumptions about how your offline-enabled app will work.</span></span>

<span data-ttu-id="03c6e-145">Çevrimdışı desteğin nasıl çalıştığını görmek için:</span><span class="sxs-lookup"><span data-stu-id="03c6e-145">To see how offline support works:</span></span>

1. <span data-ttu-id="03c6e-146">Uygulamayı yayınlayın.</span><span class="sxs-lookup"><span data-stu-id="03c6e-146">Publish the app.</span></span> <span data-ttu-id="03c6e-147">Daha fazla bilgi için bkz. <xref:host-and-deploy/blazor/index#publish-the-app>.</span><span class="sxs-lookup"><span data-stu-id="03c6e-147">For more information, see <xref:host-and-deploy/blazor/index#publish-the-app>.</span></span>
1. <span data-ttu-id="03c6e-148">Uygulamayı HTTPS'yi destekleyen bir sunucuya dağıtın ve uygulamanın güvenli HTTPS adresinden bir tarayıcıda erişin.</span><span class="sxs-lookup"><span data-stu-id="03c6e-148">Deploy the app to a server that supports HTTPS, and access the app in a browser at its secure HTTPS address.</span></span>
1. <span data-ttu-id="03c6e-149">Tarayıcının dev araçlarını açın ve Bir *Hizmet Çalışanının* **Uygulama** sekmesinde ana bilgisayar için kayıtlı olduğunu doğrulayın:</span><span class="sxs-lookup"><span data-stu-id="03c6e-149">Open the browser's dev tools and verify that a *Service Worker* is registered for the host on the **Application** tab:</span></span>

   ![Google Chrome geliştirici araçları 'Uygulama' sekmesi, etkinleştirilen ve çalışan bir Servis Çalışanı'nı gösterir.](progressive-web-app/_static/image4.png)

1. <span data-ttu-id="03c6e-151">Sayfayı yeniden yükleyin ve **Ağ** sekmesini inceleyin. **Hizmet Çalışanı** veya **bellek önbelleği** sayfanın tüm varlıklarının kaynağı olarak listelenir:</span><span class="sxs-lookup"><span data-stu-id="03c6e-151">Reload the page and examine the **Network** tab. **Service Worker** or **memory cache** are listed as the sources for all of the page's assets:</span></span>

   ![Google Chrome geliştirici araçları 'Ağ' sekmesi, sayfanın tüm varlıklarıiçin kaynakları gösterir.](progressive-web-app/_static/image5.png)

1. <span data-ttu-id="03c6e-153">Uygulamayı yüklemek için tarayıcının ağ erişimine bağlı olmadığını doğrulamak için aşağıdakileri de:</span><span class="sxs-lookup"><span data-stu-id="03c6e-153">To verify that the browser isn't dependent on network access to load the app, either:</span></span>

   * <span data-ttu-id="03c6e-154">Web sunucusunu kapatın ve uygulamanın sayfa yeniden yüklemelerini içeren normal şekilde nasıl çalışmaya devam ettiğine bakın.</span><span class="sxs-lookup"><span data-stu-id="03c6e-154">Shut down the web server and see how the app continues to function normally, which includes page reloads.</span></span> <span data-ttu-id="03c6e-155">Aynı şekilde, yavaş bir ağ bağlantısı olduğunda uygulama normal şekilde çalışmaya devam eder.</span><span class="sxs-lookup"><span data-stu-id="03c6e-155">Likewise, the app continues to function normally when there's a slow network connection.</span></span>
   * <span data-ttu-id="03c6e-156">Tarayıcıya **Ağ** sekmesinde çevrimdışı modu simüle etmesini öğretin:</span><span class="sxs-lookup"><span data-stu-id="03c6e-156">Instruct the browser to simulate offline mode in the **Network** tab:</span></span>

   ![Tarayıcı modu ile Google Chrome geliştirici araçları 'Ağ' sekmesi 'Çevrimiçi' 'Çevrimdışı' olarak değiştiriliyor.](progressive-web-app/_static/image6.png)

<span data-ttu-id="03c6e-158">Bir hizmet çalışanı kullanarak çevrimdışı destek bir web Blazorstandardı, belirli değildir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-158">Offline support using a service worker is a web standard, not specific to Blazor.</span></span> <span data-ttu-id="03c6e-159">Hizmet çalışanları hakkında daha fazla bilgi için [MDN web dokümanlarına bakın: Servis Görevlisi API' si.](https://developer.mozilla.org/docs/Web/API/Service_Worker_API)</span><span class="sxs-lookup"><span data-stu-id="03c6e-159">For more information on service workers, see [MDN web docs: Service Worker API](https://developer.mozilla.org/docs/Web/API/Service_Worker_API).</span></span> <span data-ttu-id="03c6e-160">Hizmet çalışanları için yaygın kullanım alışkanlıkları hakkında daha fazla bilgi edinmek için [Google Web: Hizmet Çalışanı Yaşam Döngüsü'ne](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle)bakın.</span><span class="sxs-lookup"><span data-stu-id="03c6e-160">To learn more about common usage patterns for service workers, see [Google Web: The Service Worker Lifecycle](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle).</span></span>

Blazor<span data-ttu-id="03c6e-161">'S PWA şablonu iki hizmet çalışanı dosyası üretir:</span><span class="sxs-lookup"><span data-stu-id="03c6e-161">'s PWA template produces two service worker files:</span></span>

* <span data-ttu-id="03c6e-162">geliştirme sırasında kullanılan *wwwroot/service-worker.js.*</span><span class="sxs-lookup"><span data-stu-id="03c6e-162">*wwwroot/service-worker.js*, which is used during development.</span></span>
* <span data-ttu-id="03c6e-163">*wwwroot/service-worker.published.js*, uygulama yayınlandıktan sonra kullanılır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-163">*wwwroot/service-worker.published.js*, which is used after the app is published.</span></span>

<span data-ttu-id="03c6e-164">İki hizmet çalışanı dosyası arasında mantık paylaşmak için aşağıdaki yaklaşımı göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="03c6e-164">To share logic between the two service worker files, consider the following approach:</span></span>

* <span data-ttu-id="03c6e-165">Ortak mantığı tutmak için üçüncü bir JavaScript dosyası ekleyin.</span><span class="sxs-lookup"><span data-stu-id="03c6e-165">Add a third JavaScript file to hold the common logic.</span></span>
* <span data-ttu-id="03c6e-166">Ortak mantığı her iki servis çalışanı dosyasına yüklemek için [self.importScripts'i](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts) kullanın.</span><span class="sxs-lookup"><span data-stu-id="03c6e-166">Use [self.importScripts](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts) to load the common logic into both service worker files.</span></span>

### <a name="cache-first-fetch-strategy"></a><span data-ttu-id="03c6e-167">Önbellek-ilk getirme stratejisi</span><span class="sxs-lookup"><span data-stu-id="03c6e-167">Cache-first fetch strategy</span></span>

<span data-ttu-id="03c6e-168">Yerleşik hizmet *çalışanı.published.js* servis çalışanı istekleri *önbellek ilk* stratejisini kullanarak çözer.</span><span class="sxs-lookup"><span data-stu-id="03c6e-168">The built-in *service-worker.published.js* service worker resolves requests using a *cache-first* strategy.</span></span> <span data-ttu-id="03c6e-169">Bu, kullanıcının ağ erişimine sahip olup olmadığına veya sunucuda yeni içerik bulunup bulunmadığına bakılmaksızın, hizmet çalışanının önbelleğe alınmış içeriği döndürmeyi tercih ettiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-169">This means that the service worker prefers to return cached content, regardless of whether the user has network access or newer content is available on the server.</span></span>

<span data-ttu-id="03c6e-170">Önbellek ilk stratejisi değerlidir, çünkü:</span><span class="sxs-lookup"><span data-stu-id="03c6e-170">The cache-first strategy is valuable because:</span></span>

* <span data-ttu-id="03c6e-171">**Güvenilirliği sağlar.**</span><span class="sxs-lookup"><span data-stu-id="03c6e-171">**It ensures reliability.**</span></span> <span data-ttu-id="03c6e-172">&ndash;Ağ erişimi boolean durumu değildir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-172">&ndash; Network access isn't a boolean state.</span></span> <span data-ttu-id="03c6e-173">Bir kullanıcı yalnızca çevrimiçi veya çevrimdışı değildir:</span><span class="sxs-lookup"><span data-stu-id="03c6e-173">A user isn't simply online or offline:</span></span>

  * <span data-ttu-id="03c6e-174">Kullanıcının aygıtı çevrimiçi olduğunu varsayabilir, ancak ağ beklemek için pratik olacak kadar yavaş olabilir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-174">The user's device may assume it's online, but the network might be so slow as to be impractical to wait for.</span></span>
  * <span data-ttu-id="03c6e-175">Ağ, belirli istekleri engelleyen veya yeniden yönlendiren bir tutsak WIFI portalı olması gibi belirli URL'ler için geçersiz sonuçlar döndürebilir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-175">The network might return invalid results for certain URLs, such as when there's a captive WIFI portal that's currently blocking or redirecting certain requests.</span></span>
  
  <span data-ttu-id="03c6e-176">Bu nedenle tarayıcının `navigator.onLine` API'si güvenilir değildir ve bağımlı olmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-176">This is why the browser's `navigator.onLine` API isn't reliable and shouldn't be depended upon.</span></span>

* <span data-ttu-id="03c6e-177">**Doğruluğu sağlar.**</span><span class="sxs-lookup"><span data-stu-id="03c6e-177">**It ensures correctness.**</span></span> <span data-ttu-id="03c6e-178">&ndash;Hizmet çalışanı, çevrimdışı kaynakların önbelleğini yaparken, kaynakların tek bir anda tam ve kendi kendine tutarlı anlık görüntüsünü aldığını garanti etmek için içerik karmalarını kullanır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-178">&ndash; When building a cache of offline resources, the service worker uses content hashing to guarantee it has fetched a complete and self-consistent snapshot of resources at a single instant in time.</span></span> <span data-ttu-id="03c6e-179">Bu önbellek daha sonra atomik birim olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-179">This cache is then used as an atomic unit.</span></span> <span data-ttu-id="03c6e-180">Gereken tek sürümler zaten önbelleğe alınmış olanlardır, yeni kaynaklar için ağ dan istemenin bir anlamı yoktur.</span><span class="sxs-lookup"><span data-stu-id="03c6e-180">There's no point asking the network for newer resources, since the only versions required are the ones already cached.</span></span> <span data-ttu-id="03c6e-181">Başka bir şey tutarsızlık ve uyumsuzluk riski (örneğin, birlikte derlenmemiş .NET derlemelerinin sürümlerini kullanmaya çalışmak).</span><span class="sxs-lookup"><span data-stu-id="03c6e-181">Anything else risks inconsistency and incompatibility (for example, trying to use versions of .NET assemblies that weren't compiled together).</span></span>

### <a name="background-updates"></a><span data-ttu-id="03c6e-182">Arka plan güncellemeleri</span><span class="sxs-lookup"><span data-stu-id="03c6e-182">Background updates</span></span>

<span data-ttu-id="03c6e-183">Bir zihinsel model olarak, çevrimdışı ilk PWA'nın yüklenebilecek bir mobil uygulama gibi davrandığını düşünebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="03c6e-183">As a mental model, you can think of an offline-first PWA as behaving like a mobile app that can be installed.</span></span> <span data-ttu-id="03c6e-184">Uygulama, ağ bağlantısından bağımsız olarak hemen başlar, ancak yüklenen uygulama mantığı en son sürüm olmayan bir anlık görüntüden gelir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-184">The app starts up immediately regardless of network connectivity, but the installed app logic comes from a point-in-time snapshot that might not be the latest version.</span></span>

<span data-ttu-id="03c6e-185">PWA şablonu, Blazor kullanıcı ziyaret ettiğinde ve çalışan bir ağ bağlantısı olduğunda kendilerini arka planda otomatik olarak güncellemeye çalışan uygulamalar üretir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-185">The Blazor PWA template produces apps that automatically try to update themselves in the background whenever the user visits and has a working network connection.</span></span> <span data-ttu-id="03c6e-186">Bu çalışma şekli aşağıdaki gibidir:</span><span class="sxs-lookup"><span data-stu-id="03c6e-186">The way this works is as follows:</span></span>

* <span data-ttu-id="03c6e-187">Derleme sırasında, proje bir *hizmet çalışanı varlıkları tezahür oluşturur.*</span><span class="sxs-lookup"><span data-stu-id="03c6e-187">During compilation, the project generates a *service worker assets manifest*.</span></span> <span data-ttu-id="03c6e-188">Varsayılan olarak, bu *hizmet-işçi-varlıklar.js*denir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-188">By default, this is called *service-worker-assets.js*.</span></span> <span data-ttu-id="03c6e-189">Bildirim, uygulamanın çevrimdışı çalışması için gereken .NET derlemeleri, JavaScript dosyaları ve css gibi içerik zorlukları da dahil olmak üzere gereken tüm statik kaynakları listeler.</span><span class="sxs-lookup"><span data-stu-id="03c6e-189">The manifest lists all the static resources that the app requires to function offline, such as .NET assemblies, JavaScript files, and CSS, including their content hashes.</span></span> <span data-ttu-id="03c6e-190">Kaynak listesi, hangi kaynakların önbelleğe alındığını bilmesi için servis çalışanı tarafından yüklenir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-190">The resource list is loaded by the service worker so that it knows which resources to cache.</span></span>
* <span data-ttu-id="03c6e-191">Kullanıcı uygulamayı her ziyaret edinde, tarayıcı arka planda *servis-worker.js* ve *hizmet-worker-assets.js'yi* yeniden talep eder.</span><span class="sxs-lookup"><span data-stu-id="03c6e-191">Each time the user visits the app, the browser re-requests *service-worker.js* and *service-worker-assets.js* in the background.</span></span> <span data-ttu-id="03c6e-192">Dosyalar, varolan yüklenen servis çalışanı ile bayt-byte karşılaştırılır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-192">The files are compared byte-for-byte with the existing installed service worker.</span></span> <span data-ttu-id="03c6e-193">Sunucu bu dosyalardan biri için değiştirilen içeriği döndürürse, servis çalışanı kendi sürümünü yüklemeye çalışır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-193">If the server returns changed content for either of these files, the service worker attempts to install a new version of itself.</span></span>
* <span data-ttu-id="03c6e-194">Kendi yeni bir sürümünü yüklerken, hizmet çalışanı çevrimdışı kaynaklar için yeni, ayrı bir önbellek oluşturur ve önbelleği *hizmet çalışanı-varlıklar.js'de*listelenen kaynaklarla doldurmaya başlar.</span><span class="sxs-lookup"><span data-stu-id="03c6e-194">When installing a new version of itself, the service worker creates a new, separate cache for offline resources and starts populating the cache with resources listed in *service-worker-assets.js*.</span></span> <span data-ttu-id="03c6e-195">Bu mantık `onInstall` *hizmet-worker.published.js*içinde işlevi nde uygulanır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-195">This logic is implemented in the `onInstall` function inside *service-worker.published.js*.</span></span>
* <span data-ttu-id="03c6e-196">Tüm kaynaklar hatasız yüklendiğinde ve tüm içerik kalıpları eşleştiğinde işlem başarıyla tamamlanır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-196">The process completes successfully when all of the resources are loaded without error and all content hashes match.</span></span> <span data-ttu-id="03c6e-197">Başarılı olursa, yeni hizmet çalışanı etkinleştirme durumunu *bekliyor.*</span><span class="sxs-lookup"><span data-stu-id="03c6e-197">If successful, the new service worker enters a *waiting for activation* state.</span></span> <span data-ttu-id="03c6e-198">Kullanıcı uygulamayı kapatır kapatmaz (kalan uygulama sekmeleri veya pencereler için bulunmaz), yeni servis çalışanı *etkin* hale gelir ve sonraki uygulama ziyaretleri için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-198">As soon as the user closes the app (no remaining app tabs or windows), the new service worker becomes *active* and is used for subsequent app visits.</span></span> <span data-ttu-id="03c6e-199">Eski servis çalışanı ve önbelleği silinir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-199">The old service worker and its cache are deleted.</span></span>
* <span data-ttu-id="03c6e-200">İşlem başarıyla tamamlanmazsa, yeni servis çalışanı örneği atılır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-200">If the process doesn't complete successfully, the new service worker instance is discarded.</span></span> <span data-ttu-id="03c6e-201">Güncelleştirme işlemi, istemcinin istekleri tamamlayabilecek daha iyi bir ağ bağlantısına sahip olması yla kullanıcının bir sonraki ziyaretinde yeniden denenir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-201">The update process is attempted again on the user's next visit, when hopefully the client has a better network connection that can complete the requests.</span></span>

<span data-ttu-id="03c6e-202">Hizmet çalışanı mantığını düzenleyerek bu işlemi özelleştirin.</span><span class="sxs-lookup"><span data-stu-id="03c6e-202">Customize this process by editing the service worker logic.</span></span> <span data-ttu-id="03c6e-203">Önceki davranışların hiçbiri belirli Blazor değildir, ancak yalnızca PWA şablonu seçeneği tarafından sağlanan varsayılan deneyimdir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-203">None of the preceding behavior is specific to Blazor but is merely the default experience provided by the PWA template option.</span></span> <span data-ttu-id="03c6e-204">Daha fazla bilgi için [BKZ: MDN web dokümanları: Servis Görevlisi API.](https://developer.mozilla.org/docs/Web/API/Service_Worker_API)</span><span class="sxs-lookup"><span data-stu-id="03c6e-204">For more information, see [MDN web docs: Service Worker API](https://developer.mozilla.org/docs/Web/API/Service_Worker_API).</span></span>

### <a name="how-requests-are-resolved"></a><span data-ttu-id="03c6e-205">İstekler nasıl çözülür?</span><span class="sxs-lookup"><span data-stu-id="03c6e-205">How requests are resolved</span></span>

<span data-ttu-id="03c6e-206">[Önbellek-ilk getirme stratejisi](#cache-first-fetch-strategy) bölümünde açıklandığı gibi, varsayılan hizmet çalışanı *önbellek ilk* stratejisi kullanır, yani önbelleğe alınmış içeriği kullanılabilir olduğunda sunmaya çalışır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-206">As described in the [Cache-first fetch strategy](#cache-first-fetch-strategy) section, the default service worker uses a *cache-first* strategy, meaning that it tries to serve cached content when available.</span></span> <span data-ttu-id="03c6e-207">Belirli bir URL için önbelleğe alınmış içerik yoksa (örneğin, arka uç API'den veri istenirken), servis çalışanı normal bir ağ isteğine geri döner.</span><span class="sxs-lookup"><span data-stu-id="03c6e-207">If there is no content cached for a certain URL, for example when requesting data from a backend API, the service worker falls back on a regular network request.</span></span> <span data-ttu-id="03c6e-208">Sunucuya erişilebilirse ağ isteği başarılı olur.</span><span class="sxs-lookup"><span data-stu-id="03c6e-208">The network request succeeds if the server is reachable.</span></span> <span data-ttu-id="03c6e-209">Bu mantık `onFetch` *hizmet-worker.published.js*içinde işlevi içinde uygulanır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-209">This logic is implemented inside `onFetch` function within *service-worker.published.js*.</span></span>

<span data-ttu-id="03c6e-210">Uygulamanın Razor bileşenleri arka uç API'lerinden veri istemeye güveniyorsa ve ağ kullanılabilirliği nedeniyle başarısız istekler için kolay bir kullanıcı deneyimi sağlamak istiyorsanız, uygulamanın bileşenleri içindeki mantığı uygulayın.</span><span class="sxs-lookup"><span data-stu-id="03c6e-210">If the app's Razor components rely on requesting data from backend APIs and you want to provide a friendly user experience for failed requests due to network unavailability, implement logic within the app's components.</span></span> <span data-ttu-id="03c6e-211">Örneğin, istekler `HttpClient` etrafında kullanın. `try/catch`</span><span class="sxs-lookup"><span data-stu-id="03c6e-211">For example, use `try/catch` around `HttpClient` requests.</span></span>

### <a name="support-server-rendered-pages"></a><span data-ttu-id="03c6e-212">Sunucu tarafından işlenen sayfaları destekleme</span><span class="sxs-lookup"><span data-stu-id="03c6e-212">Support server-rendered pages</span></span>

<span data-ttu-id="03c6e-213">Kullanıcı, uygulamadaki herhangi bir derin bağlantı `/counter` gibi bir URL'ye ilk gittiğinde neler olacağını düşünün.</span><span class="sxs-lookup"><span data-stu-id="03c6e-213">Consider what happens when the user first navigates to a URL such as `/counter` or any other deep link in the app.</span></span> <span data-ttu-id="03c6e-214">Bu gibi durumlarda, önbelleğe alınmış içeriği döndürmek `/counter`istemezsiniz, ancak bunun yerine WebAssembly `/index.html` uygulamanızı Blazor başlatmak için önbelleğe alınmış içeriği yüklemek için tarayıcıya ihtiyacınız vardır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-214">In these cases, you don't want to return content cached as `/counter`, but instead need the browser to load the content cached as `/index.html` to start up your Blazor WebAssembly app.</span></span> <span data-ttu-id="03c6e-215">Bu ilk istekler, şunları aksine *gezinti* istekleri olarak bilinir:</span><span class="sxs-lookup"><span data-stu-id="03c6e-215">These initial requests are known as *navigation* requests, as opposed to:</span></span>

* <span data-ttu-id="03c6e-216">resimler, stil sayfaları veya diğer dosyalar için *alt kaynak* istekleri.</span><span class="sxs-lookup"><span data-stu-id="03c6e-216">*subresource* requests for images, stylesheets, or other files.</span></span>
* <span data-ttu-id="03c6e-217">API verileri için *alma/XHR* istekleri.</span><span class="sxs-lookup"><span data-stu-id="03c6e-217">*fetch/XHR* requests for API data.</span></span>

<span data-ttu-id="03c6e-218">Varsayılan hizmet çalışanı, gezinti istekleri için özel durum mantığı içerir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-218">The default service worker contains special-case logic for navigation requests.</span></span> <span data-ttu-id="03c6e-219">Hizmet çalışanı, istenen URL'den bağımsız olarak önbelleğe alınmış içeriği `/index.html`döndürerek istekleri giderir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-219">The service worker resolves the requests by returning the cached content for `/index.html`, regardless of the requested URL.</span></span> <span data-ttu-id="03c6e-220">Bu mantık `onFetch` *hizmet-worker.published.js*içinde işlevi nde uygulanır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-220">This logic is implemented in the `onFetch` function inside *service-worker.published.js*.</span></span>

<span data-ttu-id="03c6e-221">Uygulamanızda sunucu tarafından işlenen HTML döndürülmesi gereken ve önbellekten hizmet `/index.html` alamayan belirli URL'ler varsa, servis çalışanınızdaki mantığı düzenlemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-221">If your app has certain URLs that must return server-rendered HTML, and not serve `/index.html` from the cache, then you need to edit the logic in your service worker.</span></span> <span data-ttu-id="03c6e-222">İçerdiği `/Identity/` tüm URL'lerin sunucuya düzenli çevrimiçi istekolarak ele alınması gerekiyorsa, *service-worker.published.js* `onFetch` mantığını değiştirin.</span><span class="sxs-lookup"><span data-stu-id="03c6e-222">If all URLs containing `/Identity/` need to be handled as regular online-only requests to the server, then modify *service-worker.published.js* `onFetch` logic.</span></span> <span data-ttu-id="03c6e-223">Aşağıdaki kodu bulun:</span><span class="sxs-lookup"><span data-stu-id="03c6e-223">Locate the following code:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate';
```

<span data-ttu-id="03c6e-224">Kodu aşağıdakiyle değiştirin:</span><span class="sxs-lookup"><span data-stu-id="03c6e-224">Change the code to the following:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate'
    && !event.request.url.includes('/Identity/');
```

<span data-ttu-id="03c6e-225">Bunu yapmazsanız, ağ bağlantısından bağımsız olarak, servis çalışanı bu tür URL'ler için isteklerini `/index.html`keser ve bunları kullanarak çözer.</span><span class="sxs-lookup"><span data-stu-id="03c6e-225">If you don't do this, then regardless of network connectivity, the service worker intercepts requests for such URLs and resolves them using `/index.html`.</span></span>

### <a name="control-asset-caching"></a><span data-ttu-id="03c6e-226">Varlık önbelleğe alma denetimi</span><span class="sxs-lookup"><span data-stu-id="03c6e-226">Control asset caching</span></span>

<span data-ttu-id="03c6e-227">Projeniz MSBuild `ServiceWorkerAssetsManifest` özelliğini tanımlıyorsa, Blazor'yapı aracı, belirtilen ada sahip bir hizmet çalışanı varlıkları tezahür oluşturur.</span><span class="sxs-lookup"><span data-stu-id="03c6e-227">If your project defines the `ServiceWorkerAssetsManifest` MSBuild property, Blazor's build tooling generates a service worker assets manifest with the specified name.</span></span> <span data-ttu-id="03c6e-228">Varsayılan PWA şablonu aşağıdaki özelliği içeren bir proje dosyası üretir:</span><span class="sxs-lookup"><span data-stu-id="03c6e-228">The default PWA template produces a project file containing the following property:</span></span>

```xml
<ServiceWorkerAssetsManifest>service-worker-assets.js</ServiceWorkerAssetsManifest>
```

<span data-ttu-id="03c6e-229">Dosya *wwwroot* çıktı dizini yerleştirilir, böylece tarayıcı isteyerek `/service-worker-assets.js`bu dosyayı alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="03c6e-229">The file is placed in the *wwwroot* output directory, so the browser can retrieve this file by requesting `/service-worker-assets.js`.</span></span> <span data-ttu-id="03c6e-230">Bu dosyanın içeriğini görmek için bir metin düzenleyicisinde */bin/Debug/{TARGET FRAMEWORK}/wwwroot/service-worker-assets.js'i* açın.</span><span class="sxs-lookup"><span data-stu-id="03c6e-230">To see the contents of this file, open */bin/Debug/{TARGET FRAMEWORK}/wwwroot/service-worker-assets.js* in a text editor.</span></span> <span data-ttu-id="03c6e-231">Ancak, her yapıda yeniden oluşturulduğu için dosyayı dalamayın.</span><span class="sxs-lookup"><span data-stu-id="03c6e-231">However, don't edit the file, as it's regenerated on each build.</span></span>

<span data-ttu-id="03c6e-232">Varsayılan olarak, bu bildirim listeler:</span><span class="sxs-lookup"><span data-stu-id="03c6e-232">By default, this manifest lists:</span></span>

* <span data-ttu-id="03c6e-233">.NET derlemeleri ve çevrimdışı çalışması için gereken .NET WebAssembly çalışma zamanı dosyaları gibi yönetilen tüm Blazorkaynaklar.</span><span class="sxs-lookup"><span data-stu-id="03c6e-233">Any Blazor-managed resources, such as .NET assemblies and the .NET WebAssembly runtime files required to function offline.</span></span>
* <span data-ttu-id="03c6e-234">Harici projeler ve NuGet paketleri tarafından sağlanan statik web varlıkları da dahil olmak üzere, resimler, stil sayfaları ve JavaScript dosyaları gibi uygulamanın *wwwroot* dizininde yayımlanmak için tüm kaynaklar.</span><span class="sxs-lookup"><span data-stu-id="03c6e-234">All resources for publishing to the app's *wwwroot* directory, such as images, stylesheets, and JavaScript files, including static web assets supplied by external projects and NuGet packages.</span></span>

<span data-ttu-id="03c6e-235">Bu kaynaklardan hangisinin servis çalışanı tarafından getirilip önbelleğe alınmış `onInstall` *olduğunu, hizmet işçisi.published.js'deki*mantığı düzenleyerek denetleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="03c6e-235">You can control which of these resources are fetched and cached by the service worker by editing the logic in `onInstall` in *service-worker.published.js*.</span></span> <span data-ttu-id="03c6e-236">Varsayılan olarak, hizmet çalışanı *.html*, *.css*, *.js*ve *.wasm*, ayrıca Blazor WebAssembly ' e özgü dosya türleri (*.dll*, *.pdb)* gibi tipik web dosya adı uzantılarıyla eşleşen dosyaları getirir ve önbelleğe alır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-236">By default, the service worker fetches and caches files matching typical web filename extensions such as *.html*, *.css*, *.js*, and *.wasm*, plus file types specific to Blazor WebAssembly (*.dll*, *.pdb*).</span></span>

<span data-ttu-id="03c6e-237">Uygulamanın *wwwroot* dizininde bulunmayan ek kaynaklar eklemek için, aşağıdaki örnekte gösterildiği gibi ek MSBuild `ItemGroup` girişleri tanımlayın:</span><span class="sxs-lookup"><span data-stu-id="03c6e-237">To include additional resources that aren't present in the app's *wwwroot* directory, define extra MSBuild `ItemGroup` entries, as shown in the following example:</span></span>

```xml
<ItemGroup>
  <ServiceWorkerAssetsManifestItem Include="MyDirectory\AnotherFile.json"
    RelativePath="MyDirectory\AnotherFile.json" AssetUrl="files/AnotherFile.json" />
</ItemGroup>
```

<span data-ttu-id="03c6e-238">Meta `AssetUrl` veriler, kaynağı önbelleğe alırken tarayıcının kullanması gereken temel göreli URL'yi belirtir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-238">The `AssetUrl` metadata specifies the base-relative URL that the browser should use when fetching the resource to cache.</span></span> <span data-ttu-id="03c6e-239">Bu, diskteki özgün kaynak dosya adından bağımsız olabilir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-239">This can be independent of its original source file name on disk.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="03c6e-240">A `ServiceWorkerAssetsManifestItem` eklemek, dosyanın uygulamanın *wwwroot* dizininde yayınlanmasına neden olmaz.</span><span class="sxs-lookup"><span data-stu-id="03c6e-240">Adding a `ServiceWorkerAssetsManifestItem` doesn't cause the file to be published in the app's *wwwroot* directory.</span></span> <span data-ttu-id="03c6e-241">Yayımlama çıktısı ayrı olarak denetlenmelidir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-241">The publish output must be controlled separately.</span></span> <span data-ttu-id="03c6e-242">Yalnızca `ServiceWorkerAssetsManifestItem` ek bir girişin hizmet çalışanı varlıklar bildiriminde görünmesine neden olur.</span><span class="sxs-lookup"><span data-stu-id="03c6e-242">The `ServiceWorkerAssetsManifestItem` only causes an additional entry to appear in the service worker assets manifest.</span></span>

## <a name="push-notifications"></a><span data-ttu-id="03c6e-243">Anında iletme bildirimleri</span><span class="sxs-lookup"><span data-stu-id="03c6e-243">Push notifications</span></span>

<span data-ttu-id="03c6e-244">Diğer PWA'lar Blazor gibi, bir WebAssembly PWA'sı da arka uç sunucusundan anında iletme bildirimleri alabilir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-244">Like any other PWA, a Blazor WebAssembly PWA can receive push notifications from a backend server.</span></span> <span data-ttu-id="03c6e-245">Sunucu, kullanıcı uygulamayı etkin olarak kullanmasa bile istediği zaman anında iletme bildirimleri gönderebilir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-245">The server can send push notifications at any time, even when the user isn't actively using the app.</span></span> <span data-ttu-id="03c6e-246">Örneğin, farklı bir kullanıcı ilgili bir eylem gerçekleştirdiğinde anında iletme bildirimleri gönderilebilir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-246">For example, push notifications can be sent when a different user performs a relevant action.</span></span>

<span data-ttu-id="03c6e-247">Anında iletme bildirimi gönderme mekanizması, Blazor herhangi bir teknolojiyi kullanabilen arka uç sunucusu tarafından uygulandığından, WebAssembly'den tamamen bağımsızdır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-247">The mechanism for sending a push notification is entirely independent of Blazor WebAssembly, since it's implemented by the backend server which can use any technology.</span></span> <span data-ttu-id="03c6e-248">Bir ASP.NET Core sunucusundan anında iletme bildirimleri göndermek istiyorsanız, [Blazing Pizza atölyesinde alınan yaklaşıma benzer bir teknik kullanmayı](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications)düşünün.</span><span class="sxs-lookup"><span data-stu-id="03c6e-248">If you want to send push notifications from an ASP.NET Core server, consider [using a technique similar to the approach taken in the Blazing Pizza workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications).</span></span>

<span data-ttu-id="03c6e-249">Hizmet çalışanı JavaScript dosyasında uygulandığından, istemciye anında Blazor iletme bildirimi alma ve görüntüleme mekanizması da WebAssembly'den bağımsızdır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-249">The mechanism for receiving and displaying a push notification on the client is also independent of Blazor WebAssembly, since it's implemented in the service worker JavaScript file.</span></span> <span data-ttu-id="03c6e-250">Örneğin, [Blazing Pizza atölyesinde kullanılan yaklaşıma](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications)bakın.</span><span class="sxs-lookup"><span data-stu-id="03c6e-250">For an example, see [the approach used in the Blazing Pizza workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications).</span></span>

## <a name="caveats-for-offline-pwas"></a><span data-ttu-id="03c6e-251">Çevrimdışı PWA'lar için uyarılar</span><span class="sxs-lookup"><span data-stu-id="03c6e-251">Caveats for offline PWAs</span></span>

<span data-ttu-id="03c6e-252">Tüm uygulamalar çevrimdışı kullanımı desteklemeye çalışmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-252">Not all apps should attempt to support offline use.</span></span> <span data-ttu-id="03c6e-253">Çevrimdışı destek, her zaman gerekli kullanım örnekleri için alakalı olmamakla birlikte önemli bir karmaşıklık ekler.</span><span class="sxs-lookup"><span data-stu-id="03c6e-253">Offline support adds significant complexity, while not always being relevant for the use cases required.</span></span>

<span data-ttu-id="03c6e-254">Çevrimdışı destek genellikle yalnızca alakalıdır:</span><span class="sxs-lookup"><span data-stu-id="03c6e-254">Offline support is usually relevant only:</span></span>

* <span data-ttu-id="03c6e-255">Birincil veri deposu tarayıcıya yerelse.</span><span class="sxs-lookup"><span data-stu-id="03c6e-255">If the primary data store is local to the browser.</span></span> <span data-ttu-id="03c6e-256">Örneğin, yaklaşım, verileri `localStorage` depolayan bir IoT aygıtı veya [IndexedDB'nin](https://developer.mozilla.org/docs/Web/API/IndexedDB_API)bir [uot](https://en.wikipedia.org/wiki/Internet_of_things) aygıtına sahip bir uygulamada alakalıdır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-256">For example, the approach is relevant in an app with a UI for an [IoT](https://en.wikipedia.org/wiki/Internet_of_things) device that stores data in `localStorage` or [IndexedDB](https://developer.mozilla.org/docs/Web/API/IndexedDB_API).</span></span>
* <span data-ttu-id="03c6e-257">Uygulama, verileri çevrimdışı olarak gezinmeleri için her kullanıcıyla alakalı arka uç API verilerini almak ve önbelleğe almak için önemli miktarda çalışma yaparsa.</span><span class="sxs-lookup"><span data-stu-id="03c6e-257">If the app performs a significant amount of work to fetch and cache the backend API data relevant to each user so that they can navigate through the data offline.</span></span> <span data-ttu-id="03c6e-258">Uygulamanın düzenlemeyi desteklemesi gerekiyorsa, değişiklikleri izlemek ve verileri arka uçla eşitlemek için bir sistem oluşturulmalıdır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-258">If the app must support editing, a system for tracking changes and synchronizing data with the backend must be built.</span></span>
* <span data-ttu-id="03c6e-259">Amaç, uygulamanın ağ koşullarından bağımsız olarak hemen yüklediğini garanti etmekse.</span><span class="sxs-lookup"><span data-stu-id="03c6e-259">If the goal is to guarantee that the app loads immediately regardless of network conditions.</span></span> <span data-ttu-id="03c6e-260">Taleplerin ilerlemesini göstermek ve ağ kullanılabilirliği nedeniyle istekleri başarısız olduğunda incelikle hareket etmek için arka uç API istekleri etrafında uygun bir kullanıcı deneyimi uygulayın.</span><span class="sxs-lookup"><span data-stu-id="03c6e-260">Implement a suitable user experience around backend API requests to show the progress of requests and behave gracefully when requests fail due to network unavailability.</span></span>

<span data-ttu-id="03c6e-261">Ayrıca, çevrimdışı özellikli PWA'lar bir dizi ek komplikasyonla uğraşmak zorundadır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-261">Additionally, offline-capable PWAs must deal with a range of additional complications.</span></span> <span data-ttu-id="03c6e-262">Geliştiriciler dikkatle aşağıdaki bölümlerde uyarılar ile kendilerini tanımak gerekir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-262">Developers should carefully familiarize themselves with the caveats in the following sections.</span></span>

### <a name="offline-support-only-when-published"></a><span data-ttu-id="03c6e-263">Yalnızca yayımlandığında çevrimdışı destek</span><span class="sxs-lookup"><span data-stu-id="03c6e-263">Offline support only when published</span></span>

<span data-ttu-id="03c6e-264">Geliştirme sırasında genellikle her değişikliğin arka plan güncelleştirme işleminden geçmeden tarayıcıya hemen yansıtTığını görmek istersiniz.</span><span class="sxs-lookup"><span data-stu-id="03c6e-264">During development you typically want to see each change reflected immediately in the browser without going through a background update process.</span></span> <span data-ttu-id="03c6e-265">Bu Blazornedenle, 'PWA şablonu yalnızca yayımlandığında çevrimdışı destek sağlar.</span><span class="sxs-lookup"><span data-stu-id="03c6e-265">Therefore, Blazor's PWA template enables offline support only when published.</span></span>

<span data-ttu-id="03c6e-266">Çevrimdışı özellikli bir uygulama yaparken, uygulamayı Geliştirme ortamında sınamak yeterli değildir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-266">When building an offline-capable app, it's not enough to test the app in the Development environment.</span></span> <span data-ttu-id="03c6e-267">Uygulamayı farklı ağ koşullarına nasıl yanıt veriyi anlamak için yayımlanmış durumunda sınamalısınız.</span><span class="sxs-lookup"><span data-stu-id="03c6e-267">You must test the app in its published state to understand how it responds to different network conditions.</span></span>

### <a name="update-completion-after-user-navigation-away-from-app"></a><span data-ttu-id="03c6e-268">Kullanıcı uygulamasından uygulamadan uzaklaştıktan sonra tamamlanmayı güncelleştirme</span><span class="sxs-lookup"><span data-stu-id="03c6e-268">Update completion after user navigation away from app</span></span>

<span data-ttu-id="03c6e-269">Kullanıcı tüm sekmelerde uygulamadan uzaklaşana kadar güncellemeler tamamlanmaz.</span><span class="sxs-lookup"><span data-stu-id="03c6e-269">Updates don't complete until the user has navigated away from the app in all tabs.</span></span> <span data-ttu-id="03c6e-270">Arka Plan [güncellemeleri](#background-updates) bölümünde açıklandığı gibi, uygulamaya bir güncelleştirme dağıttıktan sonra, tarayıcı güncelleştirme işlemini başlatmak için güncelleştirilmiş servis çalışanı dosyalarını getirir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-270">As explained in the [Background updates](#background-updates) section, after you deploy an update to the app, the browser fetches the updated service worker files to begin the update process.</span></span>

<span data-ttu-id="03c6e-271">Birçok geliştiriciyi şaşırtan şey, bu güncelleştirme tamamlandığında bile, kullanıcı tüm sekmelerde gezinene kadar etkili **olmamasıdır.**</span><span class="sxs-lookup"><span data-stu-id="03c6e-271">What surprises many developers is that, even when this update completes, it does **not** take effect until the user has navigated away in all tabs.</span></span> <span data-ttu-id="03c6e-272">Uygulamayı görüntüleyen tek sekme olsa bile, uygulamayı görüntüleyen sekmeyi yenilemek yeterli **değildir.**</span><span class="sxs-lookup"><span data-stu-id="03c6e-272">It is **not** sufficient to refresh the tab displaying the app, even if it's the only tab displaying the app.</span></span> <span data-ttu-id="03c6e-273">Uygulamanız tamamen kapatılana kadar, yeni servis çalışanı durumu *etkinleştirmek için beklemede* kalır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-273">Until your app is completely closed, the new service worker remains in the *waiting to activate* status.</span></span> <span data-ttu-id="03c6e-274">**BlazorBu, belirli değildir, ancak daha ziyade standart bir web platformu davranışıdır.**</span><span class="sxs-lookup"><span data-stu-id="03c6e-274">**This is not specific to Blazor, but rather is a standard web platform behavior.**</span></span>

<span data-ttu-id="03c6e-275">Bu genellikle, hizmet çalışanları veya çevrimdışı önbelleğe alınmış kaynakların güncelleştirmelerini sınamaya çalışan geliştiricileri rahatsız ediyor.</span><span class="sxs-lookup"><span data-stu-id="03c6e-275">This commonly troubles developers who are trying to test updates to their service worker or offline cached resources.</span></span> <span data-ttu-id="03c6e-276">Tarayıcının geliştirici araçlarını iade ederseniz, aşağıdaki gibi bir şey görebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="03c6e-276">If you check in the browser's developer tools, you may see something like the following:</span></span>

![Google Chrome 'Uygulama' sekmesi, uygulamanın Servis Görevlisi'nin 'etkinleştirmeyi beklediğini' gösterir.](progressive-web-app/_static/image7.png)

<span data-ttu-id="03c6e-278">Uygulamanızı görüntüleyen sekmeler veya pencereler olan "istemciler" listesi boş değilken, çalışan beklemeye devam eder.</span><span class="sxs-lookup"><span data-stu-id="03c6e-278">For as long as the list of "clients," which are tabs or windows displaying your app, is nonempty, the worker continues waiting.</span></span> <span data-ttu-id="03c6e-279">Servis çalışanlarının bunu yapmasının nedeni tutarlılığı garanti etmektir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-279">The reason service workers do this is to guarantee consistency.</span></span> <span data-ttu-id="03c6e-280">Tutarlılık, tüm kaynakların aynı atomik önbellekten geldiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-280">Consistency means that all resources are fetched from the same atomic cache.</span></span>

<span data-ttu-id="03c6e-281">Değişiklikleri sınarken, önceki ekran görüntüsünde gösterildiği gibi "skipWaiting" bağlantısını tıklatıp sayfayı yeniden yüklemeyi uygun bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="03c6e-281">When testing changes, you may find it convenient to click the "skipWaiting" link as shown in the preceding screenshot, then reload the page.</span></span> <span data-ttu-id="03c6e-282">Bunu tüm kullanıcılar için ["bekleme" aşamasını atlamak ve güncelleştirmede hemen etkinleştirmek](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase)için servis çalışanınızı kodlayarak otomatikleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="03c6e-282">You can automate this for all users by coding your service worker to [skip the "waiting" phase and immediately activate on update](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase).</span></span> <span data-ttu-id="03c6e-283">Bekleme aşamasını atlarsanız, kaynakların her zaman aynı önbellek örneğinden sürekli olarak getirilme garantisinden vazgeçmiş olursunuz.</span><span class="sxs-lookup"><span data-stu-id="03c6e-283">If you skip the waiting phase, you're giving up the guarantee that resources are always fetched consistently from the same cache instance.</span></span>

### <a name="users-may-run-any-historical-version-of-the-app"></a><span data-ttu-id="03c6e-284">Kullanıcılar uygulamanın herhangi bir tarihsel sürümünü çalıştırabilir</span><span class="sxs-lookup"><span data-stu-id="03c6e-284">Users may run any historical version of the app</span></span>

<span data-ttu-id="03c6e-285">Web geliştiricileri, geleneksel web dağıtım modelinde normal olduğundan, kullanıcıların yalnızca web uygulamalarının en son dağıtılan sürümünü çalıştırmalarını beklerler.</span><span class="sxs-lookup"><span data-stu-id="03c6e-285">Web developers habitually expect that users only run the latest deployed version of their web app, since that's normal within the traditional web distribution model.</span></span> <span data-ttu-id="03c6e-286">Ancak, çevrimdışı ilk PWA, kullanıcıların en son sürümü çalıştırmadığı yerel bir mobil uygulamaya daha çok benzer.</span><span class="sxs-lookup"><span data-stu-id="03c6e-286">However, an offline-first PWA is more akin to a native mobile app, where users aren't necessarily running the latest version.</span></span>

<span data-ttu-id="03c6e-287">Arka Plan [güncellemeleri](#background-updates) bölümünde açıklandığı gibi, uygulamanıza bir güncelleştirme dağıttıktan sonra, güncelleme arka planda gerçekleştiği nden ve kullanıcı daha sonra uzaklaşana kadar etkinleştirilmediği **için, her varolan kullanıcı en az bir ziyaret için önceki sürümü kullanmaya devam eder.**</span><span class="sxs-lookup"><span data-stu-id="03c6e-287">As explained in the [Background updates](#background-updates) section, after you deploy an update to your app, **each existing user continues to use a previous version for at least one further visit** because the update occurs in the background and isn't activated until the user thereafter navigates away.</span></span> <span data-ttu-id="03c6e-288">Ayrıca, kullanılan önceki sürüm, dağıttığınız önceki sürüm olması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="03c6e-288">Plus, the previous version being used isn't necessarily the previous one you deployed.</span></span> <span data-ttu-id="03c6e-289">Önceki sürüm, kullanıcının bir güncelleştirmeyi en son ne zaman tamamladıkladığına bağlı olarak *geçmiş* bir sürüm olabilir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-289">The previous version can be *any* historical version, depending on when the user last completed an update.</span></span>

<span data-ttu-id="03c6e-290">Uygulamanızın ön ve arka uç bölümleri API istekleri için şema hakkında anlaşma gerektiriyorsa, bu bir sorun olabilir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-290">This can be an issue if the frontend and backend parts of your app require agreement about the schema for API requests.</span></span> <span data-ttu-id="03c6e-291">Tüm kullanıcıların yükselttiğini emin olana kadar geriye dönük uyumsuz API şeması değişiklikleri dağıtmamalısınız.</span><span class="sxs-lookup"><span data-stu-id="03c6e-291">You must not deploy backward-incompatible API schema changes until you can be sure that all users have upgraded.</span></span> <span data-ttu-id="03c6e-292">Alternatif olarak, kullanıcıların uygulamanın uyumsuz eski sürümlerini kullanmasını engelleyin.</span><span class="sxs-lookup"><span data-stu-id="03c6e-292">Alternatively, block users from using incompatible older versions of the app.</span></span> <span data-ttu-id="03c6e-293">Bu senaryo gereksinimi, yerel mobil uygulamalarla aynıdır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-293">This scenario requirement is the same as for native mobile apps.</span></span> <span data-ttu-id="03c6e-294">Sunucu API'lerinde bir son dakika değişikliği dağıtırsanız, istemci uygulaması henüz güncellenmemiş kullanıcılar için bozukolur.</span><span class="sxs-lookup"><span data-stu-id="03c6e-294">If you deploy a breaking change in server APIs, the client app is broken for users who haven't yet updated.</span></span>

<span data-ttu-id="03c6e-295">Mümkünse, arka uç API'lerinizde çığır açan değişiklikleri dağıtmayın.</span><span class="sxs-lookup"><span data-stu-id="03c6e-295">If possible, don't deploy breaking changes to your backend APIs.</span></span> <span data-ttu-id="03c6e-296">Bunu yapmanız gerekiyorsa, uygulamanın güncel olup olmadığını ve kullanılmayacağını belirlemek için [ServiceWorkerRegistration gibi standart Servis Görevlisi API'lerini](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration) kullanmayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="03c6e-296">If you must do so, consider using [standard Service Worker APIs such as ServiceWorkerRegistration](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration) to determine whether the app is up-to-date, and if not, to prevent usage.</span></span>

### <a name="interference-with-server-rendered-pages"></a><span data-ttu-id="03c6e-297">Sunucu tarafından işlenen sayfalara müdahale</span><span class="sxs-lookup"><span data-stu-id="03c6e-297">Interference with server-rendered pages</span></span>

<span data-ttu-id="03c6e-298">Destek sunucusu [tarafından işlenen sayfalar](#support-server-rendered-pages) bölümünde açıklandığı gibi, servis çalışanının tüm gezinti istekleri `/index.html` için iade edilen içeriği davranışını atlamak istiyorsanız, servis çalışanınızdaki mantığı düzenleme.</span><span class="sxs-lookup"><span data-stu-id="03c6e-298">As described in the [Support server-rendered pages](#support-server-rendered-pages) section, if you want to bypass the service worker's behavior of returning `/index.html` contents for all navigation requests, edit the logic in your service worker.</span></span>

### <a name="all-service-worker-asset-manifest-contents-are-cached-by-default"></a><span data-ttu-id="03c6e-299">Tüm hizmet çalışanı varlık bildirimi içeriği varsayılan olarak önbelleğe alınır</span><span class="sxs-lookup"><span data-stu-id="03c6e-299">All service worker asset manifest contents are cached by default</span></span>

<span data-ttu-id="03c6e-300">Denetim varlık [önbelleğe alma](#control-asset-caching) bölümünde açıklandığı gibi, dosya *hizmeti-işçi-varlıklar.js* oluşturma sırasında oluşturulur ve hizmet çalışanının getirmesi ve önbelleğe alması gereken tüm varlıkları listeler.</span><span class="sxs-lookup"><span data-stu-id="03c6e-300">As described in the [Control asset caching](#control-asset-caching) section, the file *service-worker-assets.js* is generated during build and lists all assets the service worker should fetch and cache.</span></span>

<span data-ttu-id="03c6e-301">Varsayılan olarak bu liste, harici paketler ve projeler tarafından sağlanan içerik de dahil olmak üzere *wwwroot'a*yayılan her şeyi içerdiğinden, oraya çok fazla içerik koymamaya dikkat etmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="03c6e-301">Since this list by default includes everything emitted to *wwwroot*, including content supplied by external packages and projects, you must be careful not to put too much content there.</span></span> <span data-ttu-id="03c6e-302">*wwwroot* dizini milyonlarca görüntü içeriyorsa, servis çalışanı hepsini almaya ve önbelleğe almaya çalışır, aşırı bant genişliği tüketir ve büyük olasılıkla başarılı bir şekilde tamamlanmaz.</span><span class="sxs-lookup"><span data-stu-id="03c6e-302">If the *wwwroot* directory contains millions of images, the service worker tries to fetch and cache them all, consuming excessive bandwidth and most likely not completing successfully.</span></span>

<span data-ttu-id="03c6e-303">Bildirimin içeriğinin hangi alt kümesinin alınması ve *hizmet-worker.published.js* `onInstall` işlevi düzenlenerek önbelleğe alınması gerektiğini denetlemek için rasgele mantık uygulayın.</span><span class="sxs-lookup"><span data-stu-id="03c6e-303">Implement arbitrary logic to control which subset of the manifest's contents should be fetched and cached by editing the `onInstall` function in *service-worker.published.js*.</span></span>

### <a name="interaction-with-authentication"></a><span data-ttu-id="03c6e-304">Kimlik doğrulama ile etkileşim</span><span class="sxs-lookup"><span data-stu-id="03c6e-304">Interaction with authentication</span></span>

<span data-ttu-id="03c6e-305">Kimlik doğrulama seçenekleriyle birlikte PWA şablonu seçeneğini kullanmak mümkündür.</span><span class="sxs-lookup"><span data-stu-id="03c6e-305">It's possible to use the PWA template option in conjunction with the authentication options.</span></span> <span data-ttu-id="03c6e-306">Çevrimdışı özellikli bir PWA, kullanıcı ağ bağlantısına sahipolduğunda kimlik doğrulamayı da destekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-306">An offline-capable PWA can also support authentication when the user has network connectivity.</span></span>

<span data-ttu-id="03c6e-307">Bir kullanıcıağ bağlantısı yoksa, kimlik doğrulaması yapamaz veya erişim belirteçleri alamaz.</span><span class="sxs-lookup"><span data-stu-id="03c6e-307">When a user doesn't have network connectivity, they can't authenticate or obtain access tokens.</span></span> <span data-ttu-id="03c6e-308">Varsayılan olarak, ağ erişimi olmadan giriş sayfasını ziyaret etmeye çalışmak bir "ağ hatası" iletisi ile sonuçlanır.</span><span class="sxs-lookup"><span data-stu-id="03c6e-308">By default, attempting to visit the login page without network access results in a "network error" message.</span></span>

<span data-ttu-id="03c6e-309">Kullanıcının kimlik doğrulaması veya erişim belirteçleri elde etmeye çalışmadan çevrimdışı yken yararlı şeyler yapmasına olanak tanıyan bir Kullanıcı Arabirimi akışı tasarlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="03c6e-309">You must design a UI flow that lets the user do useful things while offline without attempting to authenticate or obtain access tokens.</span></span> <span data-ttu-id="03c6e-310">Alternatif olarak, ağ kullanılamadığında uygulamayı zarif bir şekilde başarısız olacak şekilde tasarlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="03c6e-310">Alternatively, you can design the app to fail in a graceful way when the network isn't available.</span></span> <span data-ttu-id="03c6e-311">Bu uygulamanızda mümkün değilse, çevrimdışı desteği etkinleştirmek istemeyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="03c6e-311">If this isn't possible in your app, you might not want to enable offline support.</span></span>
