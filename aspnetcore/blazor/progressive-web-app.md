---
title: ASP.NET Core Blazor WebAssembly ile aşamalı Web uygulamaları oluşturun
author: guardrex
description: Masaüstü uygulamaları gibi davranması için modern tarayıcı özelliklerini kullanan Web uygulamaları Blazortabanlı aşamalı Web uygulamaları (PWAs) oluşturmayı öğrenin.
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc
ms.date: 03/09/2020
no-loc:
- Blazor
- SignalR
uid: blazor/progressive-web-app
ms.openlocfilehash: f1c1ce50f20bf579e67e1d4eb02cc7d9d681e354
ms.sourcegitcommit: 98bcf5fe210931e3eb70f82fd675d8679b33f5d6
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/11/2020
ms.locfileid: "79083722"
---
# <a name="build-progressive-web-applications-with-aspnet-core-opno-locblazor-webassembly"></a><span data-ttu-id="312bf-103">ASP.NET Core Blazor WebAssembly ile aşamalı Web uygulamaları oluşturun</span><span class="sxs-lookup"><span data-stu-id="312bf-103">Build Progressive Web Applications with ASP.NET Core Blazor WebAssembly</span></span>

<span data-ttu-id="312bf-104">[Steve Sanderson](https://github.com/SteveSandersonMS) tarafından</span><span class="sxs-lookup"><span data-stu-id="312bf-104">By [Steve Sanderson](https://github.com/SteveSandersonMS)</span></span>

[!INCLUDE[](~/includes/blazorwasm-preview-notice.md)]

[!INCLUDE[](~/includes/blazorwasm-3.2-template-article-notice.md)]

<span data-ttu-id="312bf-105">Aşamalı bir Web uygulaması (PWA), masaüstü uygulaması gibi davranması için modern tarayıcı API 'Leri ve özellikleri kullanan Web tabanlı bir uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="312bf-105">A Progressive Web Application (PWA) is a web-based application that uses modern browser APIs and capabilities to behave like a desktop application.</span></span> <span data-ttu-id="312bf-106">Bu yetenekler şunları içerebilir:</span><span class="sxs-lookup"><span data-stu-id="312bf-106">These capabilities can include:</span></span>

* <span data-ttu-id="312bf-107">Ağ hızından bağımsız olarak çevrimdışı çalışma ve her zaman anında yükleme</span><span class="sxs-lookup"><span data-stu-id="312bf-107">Working offline and always loading instantly, independently of network speed</span></span>
* <span data-ttu-id="312bf-108">Yalnızca bir tarayıcı penceresinde değil, kendi uygulama penceresinde çalıştırılabiliyor</span><span class="sxs-lookup"><span data-stu-id="312bf-108">Being able to run in its own application window, not just a browser window</span></span>
* <span data-ttu-id="312bf-109">Ana bilgisayar işletim sistemi (OS) başlangıç menüsü, Dock veya Ana ekranınızdan başlatılmakta</span><span class="sxs-lookup"><span data-stu-id="312bf-109">Being launched from the host operating system (OS) start menu, dock, or home screen</span></span>
* <span data-ttu-id="312bf-110">Kullanıcı uygulamayı kullanmasa bile arka uç sunucusundan anında iletme bildirimleri alınıyor</span><span class="sxs-lookup"><span data-stu-id="312bf-110">Receiving push notifications from a backend server, even while the user is not using the application</span></span>
* <span data-ttu-id="312bf-111">Arka planda otomatik olarak güncelleştirme</span><span class="sxs-lookup"><span data-stu-id="312bf-111">Automatically updating in the background</span></span>

<span data-ttu-id="312bf-112">Bir kullanıcı önce Web tarayıcılarında uygulamayı başka bir tek sayfalı uygulama (SPA) gibi bulabilir ve kullanabilir, daha sonra bu işlemi işletim sistemine yüklemek ve anında iletme bildirimlerini etkinleştirmek için devam edebilir.</span><span class="sxs-lookup"><span data-stu-id="312bf-112">A user might first discover and use the application within their web browser like any other single-page application (SPA), then later progress to installing it in their OS and enabling push notifications.</span></span> <span data-ttu-id="312bf-113">İşte bu nedenle *ilerleyen*terimi kullanıyoruz.</span><span class="sxs-lookup"><span data-stu-id="312bf-113">That's why we use the term *progressive*.</span></span>

Blazor<span data-ttu-id="312bf-114"> WebAssembly, doğru standartlara dayalı bir istemci tarafı Web uygulaması platformudur. bu nedenle, yukarıda listelenen yetenekler için gereken PWA API 'Leri de dahil olmak üzere herhangi bir tarayıcı API 'sini kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="312bf-114"> WebAssembly is a true standards-based client-side web application platform, so it can use any browser API, including PWA APIs needed for the capabilities listed above.</span></span> <span data-ttu-id="312bf-115">Bu, diğer istemci tarafı Web teknolojilerinde olduğu gibi çevrimdışı çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="312bf-115">It can work offline just like any other client-side web technology.</span></span>

## <a name="pwa-template"></a><span data-ttu-id="312bf-116">PWA şablonu</span><span class="sxs-lookup"><span data-stu-id="312bf-116">PWA template</span></span>

<span data-ttu-id="312bf-117">Yeni bir Blazor WebAssembly uygulaması oluştururken, PWA özelliklerini ekleme seçeneği sunulur.</span><span class="sxs-lookup"><span data-stu-id="312bf-117">When creating a new Blazor WebAssembly application, you are offered the option to add PWA features.</span></span> <span data-ttu-id="312bf-118">Visual Studio 'da, seçenek proje oluşturma iletişim kutusunda bir onay kutusu olarak verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="312bf-118">In Visual Studio, the option is given as a checkbox in the project creation dialog:</span></span>

![görüntü](https://user-images.githubusercontent.com/1101362/76207411-a6b54200-61f5-11ea-9dfc-6acd87a91428.png)

<span data-ttu-id="312bf-120">Projeyi komut satırında oluşturuyorsanız `--pwa` bayrağını kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="312bf-120">If you're creating the project on the command line, you can use the `--pwa` flag.</span></span> <span data-ttu-id="312bf-121">Örneğin,</span><span class="sxs-lookup"><span data-stu-id="312bf-121">For example,</span></span>

```dotnetcli
dotnet new blazorwasm --pwa -o MyNewProject
```

<span data-ttu-id="312bf-122">Her iki durumda da isterseniz bunu "ASP.NET Core barındırılan" seçeneğiyle birleştirebilirsiniz, ancak bunu yapmanız gerekmez.</span><span class="sxs-lookup"><span data-stu-id="312bf-122">In both cases, you're free to combine this with the "ASP.NET Core hosted" option if you wish, but don't have to do so.</span></span> <span data-ttu-id="312bf-123">PWA özellikleri barındırma modelinden bağımsızdır.</span><span class="sxs-lookup"><span data-stu-id="312bf-123">PWA features are independent of the hosting model.</span></span>

## <a name="installation-and-app-manifest"></a><span data-ttu-id="312bf-124">Yükleme ve uygulama bildirimi</span><span class="sxs-lookup"><span data-stu-id="312bf-124">Installation and app manifest</span></span>

<span data-ttu-id="312bf-125">PWA şablon seçeneği kullanılarak oluşturulan bir uygulama ziyaret edildiğinde, kullanıcılar uygulamayı işletim sistemi başlangıç menüsüne, Dock 'a veya giriş ekranına yüklemek için bu seçeneği vardır.</span><span class="sxs-lookup"><span data-stu-id="312bf-125">When visiting an application created using the PWA template option, users have the option to install the application into their OS's start menu, dock, or home screen.</span></span>

<span data-ttu-id="312bf-126">Bu seçeneğin sunulma şekli kullanıcının tarayıcısına bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="312bf-126">The way this option is presented depends on the user's browser.</span></span> <span data-ttu-id="312bf-127">Örneğin, Edge veya Chrome gibi masaüstü Kayıı tabanlı tarayıcıları kullanırken, URL çubuğunda bir *Ekle* düğmesi görünür:</span><span class="sxs-lookup"><span data-stu-id="312bf-127">For example, when using desktop Chromium-based browsers such as Edge or Chrome, an *Add* button appears within the URL bar:</span></span>

![görüntü](https://user-images.githubusercontent.com/1101362/76208127-f7796a80-61f6-11ea-8aea-7fba704be787.png)

<span data-ttu-id="312bf-129">İOS 'ta, ziyaretçiler Safari 'nin *Share* düğmesini ve *Add to HOMESCREEN* seçeneğini kullanarak PWA 'yı yükleyebilir.</span><span class="sxs-lookup"><span data-stu-id="312bf-129">On iOS, visitors can install the PWA using Safari's *Share* button and its *Add to Homescreen* option.</span></span> <span data-ttu-id="312bf-130">Android için Chrome 'da, kullanıcılar sağ üst köşedeki *menü* düğmesine ve ardından *Giriş ekranına Ekle*' yi seçmelidir.</span><span class="sxs-lookup"><span data-stu-id="312bf-130">On Chrome for Android, users should tap the *Menu* button in the upper-right corner, then choose *Add to Home screen*.</span></span>

<span data-ttu-id="312bf-131">Yüklendikten sonra, uygulama herhangi bir adres çubuğu olmadan kendi penceresinde görünür.</span><span class="sxs-lookup"><span data-stu-id="312bf-131">Once installed, the application appears in its own window, without any address bar.</span></span>

![görüntü](https://user-images.githubusercontent.com/1101362/76208588-e2e9a200-61f7-11ea-85e1-8c3fc849b252.png)

<span data-ttu-id="312bf-133">Pencerenin başlığını, renk şemasını, simgesini veya diğer ayrıntıları özelleştirmek için, projenizin *Wwwroot* dizinindeki `manifest.json` dosyasına bakın.</span><span class="sxs-lookup"><span data-stu-id="312bf-133">To customize the window's title, color scheme, icon, or other details, see the file `manifest.json` in your project's *wwwroot* directory.</span></span> <span data-ttu-id="312bf-134">Bu dosyanın şeması Web standartları tarafından tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="312bf-134">The schema of this file is defined by web standards.</span></span> <span data-ttu-id="312bf-135">Ayrıntılı belgeler için bkz. https://developer.mozilla.org/docs/Web/Manifest.</span><span class="sxs-lookup"><span data-stu-id="312bf-135">For detailed documentation, see https://developer.mozilla.org/docs/Web/Manifest.</span></span>

## <a name="offline-support"></a><span data-ttu-id="312bf-136">Çevrimdışı destek</span><span class="sxs-lookup"><span data-stu-id="312bf-136">Offline support</span></span>

<span data-ttu-id="312bf-137">Varsayılan olarak, PWA şablonu seçeneği kullanılarak oluşturulan uygulamalar, çevrimdışı çalışmaya yönelik desteğe sahiptir.</span><span class="sxs-lookup"><span data-stu-id="312bf-137">By default, applications created using the PWA template option have support for running offline.</span></span> <span data-ttu-id="312bf-138">Bir Kullanıcı, çevrimiçi durumdayken uygulamayı ilk kez ziyaret etmelidir, ardından tarayıcı, çevrimdışı çalışmak için gereken tüm kaynakları otomatik olarak indirip önbelleğe alırlar.</span><span class="sxs-lookup"><span data-stu-id="312bf-138">A user must first visit the application while they are online, then the browser will automatically download and cache all the resources needed to operate offline.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="312bf-139">Çevrimdışı destek yalnızca *yayımlanan* uygulamalar için etkinleştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="312bf-139">Offline support is only enabled for *published* applications.</span></span> <span data-ttu-id="312bf-140">Geliştirme sırasında etkinleştirilmez.</span><span class="sxs-lookup"><span data-stu-id="312bf-140">It is not enabled during development.</span></span> <span data-ttu-id="312bf-141">Bunun nedeni, değişikliklerin yapılması ve test edilmesi için olağan geliştirme döngüsünü kesintiye uğratacağından kaynaklanır.</span><span class="sxs-lookup"><span data-stu-id="312bf-141">This is because it would interfere with the usual development cycle of making changes and testing them.</span></span>

> [!WARNING]
> <span data-ttu-id="312bf-142">Çevrimdışı etkin bir PWA göndermek istiyorsanız anlamanız gereken [birkaç önemli uyarı ve uyarılar](#caveats-for-offline-pwas) vardır.</span><span class="sxs-lookup"><span data-stu-id="312bf-142">If you intend to ship an offline-enabled PWA, there are [several important warnings and caveats](#caveats-for-offline-pwas) you need to understand.</span></span> <span data-ttu-id="312bf-143">Bunlar, çevrimdışı PWAs 'a ait değildir ve Blazorözgü değildir.</span><span class="sxs-lookup"><span data-stu-id="312bf-143">These are inherent to offline PWAs, and not specific to Blazor.</span></span> <span data-ttu-id="312bf-144">Çevrimdışı etkin uygulamanızın nasıl çalıştığı hakkında varsayımlar yapmadan önce bu uyarıları okuduğunuzdan ve anladığınızdan emin olun.</span><span class="sxs-lookup"><span data-stu-id="312bf-144">Be sure to read and understand these caveats before making assumptions about how your offline-enabled application will work.</span></span>

<span data-ttu-id="312bf-145">Çevrimdışı desteğin nasıl çalıştığını görmek için, öncelikle [uygulamanızı yayımlayın](https://docs.microsoft.com/aspnet/core/host-and-deploy/blazor/?view=aspnetcore-3.1&tabs=visual-studio#publish-the-app)ve https 'yi destekleyen bir sunucuda barındırın.</span><span class="sxs-lookup"><span data-stu-id="312bf-145">To see how offline support works, first [publish your application](https://docs.microsoft.com/aspnet/core/host-and-deploy/blazor/?view=aspnetcore-3.1&tabs=visual-studio#publish-the-app), and host it on a server supporting HTTPS.</span></span> <span data-ttu-id="312bf-146">Uygulamayı ziyaret ettiğinizde tarayıcının geliştirme araçlarını açabiliyor ve ana bilgisayarınız için bir *hizmet çalışanının* kayıtlı olduğunu doğrulamanız gerekir:</span><span class="sxs-lookup"><span data-stu-id="312bf-146">When you visit the application, you should be able to open the browser's dev tools and verify that a *Service Worker* is registered for your host:</span></span>

![görüntü](https://user-images.githubusercontent.com/1101362/76210294-bd5e9780-61fb-11ea-9869-65c55c62803d.png)

<span data-ttu-id="312bf-148">Ayrıca, sayfayı yeniden yüklerseniz, *ağ* sekmesinde, sayfanızı yüklemek için gereken tüm kaynakların *hizmet çalışanı* veya *bellek önbelleğinden*alındığını görmeniz gerekir:</span><span class="sxs-lookup"><span data-stu-id="312bf-148">Additionally, if you reload the page, then on the *Network* tab you should see that all resources needed to load your page are being retrieved from the *Service Worker* or *Memory Cache*:</span></span>

![görüntü](https://user-images.githubusercontent.com/1101362/76210472-1d553e00-61fc-11ea-84c6-291644df709e.png)

<span data-ttu-id="312bf-150">Bu, tarayıcının, uygulamanızı yüklemek için ağ erişimine bağımlı olmadığı gösterilir.</span><span class="sxs-lookup"><span data-stu-id="312bf-150">This shows that the browser is not dependent on network access to load your application.</span></span> <span data-ttu-id="312bf-151">Bunu doğrulamak için, Web sunucunuzu kapatabilir veya tarayıcıya çevrimdışı modunun benzetimini yaparak şunları yapabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="312bf-151">To verify this, you can either shut down your web server, or instruct the browser to simulate offline mode:</span></span>

![görüntü](https://user-images.githubusercontent.com/1101362/76210556-47a6fb80-61fc-11ea-9d12-20a8f6528744.png)

<span data-ttu-id="312bf-153">Artık, Web sunucunuza erişim olmadan bile, sayfayı yeniden yüklemeniz ve uygulamanızın hala yüklenip çalışacağını görmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="312bf-153">Now, even without access to your web server, you should be able to reload the page and see that your application still loads and runs.</span></span> <span data-ttu-id="312bf-154">Benzer şekilde, çok yavaş bir ağ bağlantısını benzeseniz bile, sayfanız ağdan bağımsız olarak yüklendiği için hemen yüklenmeye devam edecektir.</span><span class="sxs-lookup"><span data-stu-id="312bf-154">Likewise, even if you simulate a very slow network connection, your page will still load immediately since it is loaded independently of the network.</span></span>

### <a name="service-worker"></a><span data-ttu-id="312bf-155">Hizmet çalışanı</span><span class="sxs-lookup"><span data-stu-id="312bf-155">Service worker</span></span>

<span data-ttu-id="312bf-156">Çevrimdışı destek, bir hizmet çalışanı kullanılarak elde edilir.</span><span class="sxs-lookup"><span data-stu-id="312bf-156">Offline support is achieved using a service worker.</span></span> <span data-ttu-id="312bf-157">Bu, Blazorözgü olmayan bir web standardıdır.</span><span class="sxs-lookup"><span data-stu-id="312bf-157">This is a web standard, not specific to Blazor.</span></span> <span data-ttu-id="312bf-158">Hizmet çalışanları hakkındaki belgeler için bkz. https://developer.mozilla.org/docs/Web/API/Service_Worker_API.</span><span class="sxs-lookup"><span data-stu-id="312bf-158">For documentation about service workers, see https://developer.mozilla.org/docs/Web/API/Service_Worker_API.</span></span> <span data-ttu-id="312bf-159">Hizmet çalışanları için ortak kullanım desenleri hakkında daha fazla bilgi edinmek için [hizmet çalışanı yaşam](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle)döngüsüne harika bir makaleye bakın.</span><span class="sxs-lookup"><span data-stu-id="312bf-159">To learn more about common usage patterns for service workers, see the excellent article [The Service Worker Lifecycle](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle).</span></span>

Blazor<span data-ttu-id="312bf-160">PWA şablonu iki hizmet çalışanı dosyası üretir:</span><span class="sxs-lookup"><span data-stu-id="312bf-160">'s PWA template produces two service worker files:</span></span>

* <span data-ttu-id="312bf-161">geliştirme sırasında kullanılan *Wwwroot/Service-Worker. js*</span><span class="sxs-lookup"><span data-stu-id="312bf-161">*wwwroot/service-worker.js*, which is used during development</span></span>
* <span data-ttu-id="312bf-162">, uygulamanız yayımlandığında kullanılan *Wwwroot/Service-Worker. yayınlanan. js*</span><span class="sxs-lookup"><span data-stu-id="312bf-162">*wwwroot/service-worker.published.js*, which is used once your application is published</span></span>

<span data-ttu-id="312bf-163">Bu iki Dosya arasında mantık paylaşmak istiyorsanız, ortak mantığı barındıracak bir üçüncü JavaScript dosyası eklemeyi düşünün ve bu mantığı her iki dosyaya da yüklemek için [`self.importScripts`](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts) kullanın.</span><span class="sxs-lookup"><span data-stu-id="312bf-163">If you want to share logic between these two files, consider adding a third JavaScript file to hold the common logic, and use [`self.importScripts`](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts) to load that logic into both files.</span></span>

#### <a name="cache-first-fetch-strategy"></a><span data-ttu-id="312bf-164">Cache-ilk getirme stratejisi</span><span class="sxs-lookup"><span data-stu-id="312bf-164">Cache-first fetch strategy</span></span>

<span data-ttu-id="312bf-165">Yerleşik *Service-Worker. yayımlanmış. js* hizmet çalışanı, istekleri bir *Cache-First* stratejisi kullanarak çözer.</span><span class="sxs-lookup"><span data-stu-id="312bf-165">The built-in *service-worker.published.js* service worker resolves requests using a *cache-first* strategy.</span></span> <span data-ttu-id="312bf-166">Bu, kullanıcının ağ erişimine sahip olup olmamasına veya sunucuda daha yeni içerik olup olmadığına bakılmaksızın, kullanılabilir olduğunda önbelleğe alınmış içerik döndürmeyi her zaman tercih ettiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="312bf-166">This means it always prefers to return cached content if available, regardless of whether the user has network access or whether newer content is available on the server.</span></span>

<span data-ttu-id="312bf-167">Bunun önemli olmasının iki nedeni vardır:</span><span class="sxs-lookup"><span data-stu-id="312bf-167">There are two reasons why this is valuable:</span></span>

* <span data-ttu-id="312bf-168">**Güvenilirlik sağlar.**</span><span class="sxs-lookup"><span data-stu-id="312bf-168">**It ensures reliability.**</span></span> <span data-ttu-id="312bf-169">Ağ erişimi Boolean bir durum değil.</span><span class="sxs-lookup"><span data-stu-id="312bf-169">Network access is not a boolean state.</span></span> <span data-ttu-id="312bf-170">Kullanıcı yalnızca "çevrimiçi" veya "çevrimdışı" değildir.</span><span class="sxs-lookup"><span data-stu-id="312bf-170">A user is not simply "online" or "offline".</span></span> <span data-ttu-id="312bf-171">Gerçekte, kullanıcının cihazı çevrimiçi olduğunu düşünmeyebilir, ancak ağ bu kadar yavaş olabilir.</span><span class="sxs-lookup"><span data-stu-id="312bf-171">In reality, the user's device may believe it is online, but the network may be so slow as to be impractical to wait for.</span></span> <span data-ttu-id="312bf-172">Ya da ağ, bazı istekleri engelleyen veya yeniden yönlendiren bir captive WIFI portalı olduğunda olduğu gibi belirli URL 'Ler için geçersiz sonuçlar döndürüyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="312bf-172">Or the network might be returning invalid results for certain URLs, such as when there is a captive WIFI portal that is currently blocking or redirecting certain requests.</span></span> <span data-ttu-id="312bf-173">Tarayıcının `navigator.onLine` API 'sinin güvenilir olmaması ve bağımlı olmaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="312bf-173">This is why the browser's `navigator.onLine` API is not reliable and should not be depended upon.</span></span>
* <span data-ttu-id="312bf-174">**Doğruluk sağlar.**</span><span class="sxs-lookup"><span data-stu-id="312bf-174">**It ensures correctness.**</span></span> <span data-ttu-id="312bf-175">Bir çevrimdışı kaynak önbelleği oluştururken hizmet çalışanı, kaynakların tek bir anında tam ve otomatik tutarlı bir anlık görüntüsünü döndürüldüğünü güvence altına almak için içerik karmaını kullanır.</span><span class="sxs-lookup"><span data-stu-id="312bf-175">When building a cache of offline resources, the service worker uses content hashing to guarantee it has fetched a complete and self-consistent snapshot of resources at a single instant in time.</span></span> <span data-ttu-id="312bf-176">Bu önbellek daha sonra atomik birim olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="312bf-176">This cache is then used as an atomic unit.</span></span> <span data-ttu-id="312bf-177">Bu, yalnızca istediğiniz sürümler zaten önbelleğe alınmış olduğundan, bu, ağ üzerinde daha yeni kaynaklar için isteyen bir nokta yoktur.</span><span class="sxs-lookup"><span data-stu-id="312bf-177">Given this, there is no point asking the network for newer resources, since the only versions you want are the ones you've already cached.</span></span> <span data-ttu-id="312bf-178">Daha fazla risk tutarsızlığı ve uyumsuzluk (örneğin, birlikte derlenmemiş .NET derlemelerinin sürümlerini kullanmaya çalışmak).</span><span class="sxs-lookup"><span data-stu-id="312bf-178">Anything else risks inconsistency and incompatibility (for example, trying to use versions of .NET assemblies that were not compiled together).</span></span>

#### <a name="background-updates"></a><span data-ttu-id="312bf-179">Arka plan güncelleştirmeleri</span><span class="sxs-lookup"><span data-stu-id="312bf-179">Background updates</span></span>

<span data-ttu-id="312bf-180">Bir akıl modeli olarak, yüklenebilen bir mobil uygulama gibi davranan bir çevrimdışı ilk PWA 'yı düşünebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="312bf-180">As a mental model, you can think of an offline-first PWA as behaving like an mobile app that can be installed.</span></span> <span data-ttu-id="312bf-181">Ağ bağlantısından bağımsız olarak her zaman hemen başlatılır, ancak yüklü uygulama mantığı, en son sürüm olmayan bir noktadan itibaren anlık görüntüden gelir.</span><span class="sxs-lookup"><span data-stu-id="312bf-181">It always starts up immediately regardless of network connectivity, but the installed application logic comes from a point-in-time snapshot that might not be the latest version.</span></span>

<span data-ttu-id="312bf-182">Blazor PWA şablonu, Kullanıcı her ziyaret ettiğinde ve çalışan bir ağ bağlantısı olduğunda otomatik olarak arka planda güncelleştirme yapmayı deneyen uygulamalar oluşturur.</span><span class="sxs-lookup"><span data-stu-id="312bf-182">The Blazor PWA template produces applications that automatically try to update themselves in the background whenever the user visits and has a working network connection.</span></span> <span data-ttu-id="312bf-183">Bu şekilde çalışma şekli şöyledir:</span><span class="sxs-lookup"><span data-stu-id="312bf-183">The way this works is as follows:</span></span>

* <span data-ttu-id="312bf-184">Derleme sırasında, projeniz bir *hizmet çalışanı varlık bildirimi*oluşturur.</span><span class="sxs-lookup"><span data-stu-id="312bf-184">During compilation, your project generates a *service worker assets manifest*.</span></span> <span data-ttu-id="312bf-185">Varsayılan olarak, *Service-Worker-assets. js*olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="312bf-185">By default this is called *service-worker-assets.js*.</span></span> <span data-ttu-id="312bf-186">Bu, uygulamanızın, içerik karmaları dahil .NET derlemeleri, JavaScript dosyaları, CSS vb. gibi çevrimdışı çalışması için gereken tüm statik kaynakları listeler.</span><span class="sxs-lookup"><span data-stu-id="312bf-186">This lists all the static resources your application needs to function offline, such as .NET assemblies, JavaScript files, CSS, etc., including their content hashes.</span></span> <span data-ttu-id="312bf-187">Bu liste, hangi kaynakların önbellekte olduğunu bilmesi için hizmet çalışanınız tarafından yüklenir.</span><span class="sxs-lookup"><span data-stu-id="312bf-187">This list is loaded by your service worker so that it knows which resources to cache.</span></span>
* <span data-ttu-id="312bf-188">Kullanıcı uygulamanızı her ziyaret ettiğinde, tarayıcı arka planda *Service-Worker. js* ve *Service-Worker-assets. js* ' yi yeniden ister.</span><span class="sxs-lookup"><span data-stu-id="312bf-188">Each time the user visits your application, the browser re-requests *service-worker.js* and *service-worker-assets.js* in the background.</span></span> <span data-ttu-id="312bf-189">Sunucu, bu dosyalardan herhangi biri için değiştirilen içeriği döndürürse (mevcut yüklü hizmet çalışanı ile bayt için bayt ile karşılaştırıldığında), hizmet çalışanı kendi yeni bir sürümünü yüklemeye çalışır.</span><span class="sxs-lookup"><span data-stu-id="312bf-189">If the server returns changed content for either of these files (compared byte-for-byte with the existing installed service worker), the service worker tries to install a new version of itself.</span></span>
* <span data-ttu-id="312bf-190">Uygulamasının yeni bir sürümü yüklenirken, hizmet çalışanı çevrimdışı kaynaklar için yeni, ayrı bir önbellek oluşturur ve *Service-Worker-assets. js*' de listelenen kaynaklarla doldurma başlatır.</span><span class="sxs-lookup"><span data-stu-id="312bf-190">When installing a new version of itself, the service worker creates a new, separate cache for offline resources, and starts populating it with resources listed in *service-worker-assets.js*.</span></span> <span data-ttu-id="312bf-191">Bu mantık, *Service-Worker. yayınlanmış. js*içindeki `onInstall` işlevinde uygulanır.</span><span class="sxs-lookup"><span data-stu-id="312bf-191">This logic is implemented in the `onInstall` function inside *service-worker.published.js*.</span></span>
* <span data-ttu-id="312bf-192">İşlem başarıyla tamamlanırsa (yani, tüm kaynaklar hatasız yüklenir ve tüm içerik karmaları eşleşiyorsa), yeni hizmet çalışanı "Etkinleştirme bekleniyor" durumuna girer.</span><span class="sxs-lookup"><span data-stu-id="312bf-192">If the process completes successfully (i.e., all the resources are loaded without error, and all content hashes match), then the new service worker enters a "waiting for activation" state.</span></span> <span data-ttu-id="312bf-193">Kullanıcı uygulamanızı kapattığında (yani, geri kalan sekme veya Windows 'u görüntüleyen pencereler yoksa), yeni hizmet çalışanı "etkin" olur ve uygulamanıza yönelik sonraki ziyaretler için kullanılacaktır.</span><span class="sxs-lookup"><span data-stu-id="312bf-193">As soon as the user closes your application (i.e., there are no remaining tabs or windows displaying your application), the new service worker becomes "active" and will be used for subsequent visits to your application.</span></span> <span data-ttu-id="312bf-194">Eski hizmet çalışanı ve önbelleği silinir.</span><span class="sxs-lookup"><span data-stu-id="312bf-194">The old service worker and its cache are deleted.</span></span>
* <span data-ttu-id="312bf-195">İşlem başarıyla tamamlanmazsa, yeni hizmet çalışanı örneği atılır.</span><span class="sxs-lookup"><span data-stu-id="312bf-195">If the process does not complete successfully, the new service worker instance is discarded.</span></span> <span data-ttu-id="312bf-196">Güncelleştirme işlemi, kullanıcının bir sonraki ziyaretinin, istekleri tamamlayabilecekleri daha iyi bir ağ bağlantısına sahip olduğu durumlarda yeniden denenir.</span><span class="sxs-lookup"><span data-stu-id="312bf-196">The update process will be attempted again on the user's next visit, when hopefully they have a better network connection that can complete the requests.</span></span>

<span data-ttu-id="312bf-197">Hizmet çalışan mantığını düzenleyerek, bu işlemin herhangi bir yönünü özelleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="312bf-197">You can customize any aspect of this process by editing the service worker logic.</span></span> <span data-ttu-id="312bf-198">Yukarıdakilerin hiçbiri Blazorözeldir, ancak yalnızca PWA şablonu seçeneği tarafından sunulan bir öneridir.</span><span class="sxs-lookup"><span data-stu-id="312bf-198">None of the above is specific to Blazor, but is merely a suggestion provided by the PWA template option.</span></span> <span data-ttu-id="312bf-199">Daha fazla bilgi için bkz. [hizmet çalışanı belgeleri](https://developer.mozilla.org/docs/Web/API/Service_Worker_API.) .</span><span class="sxs-lookup"><span data-stu-id="312bf-199">See [service worker documentation](https://developer.mozilla.org/docs/Web/API/Service_Worker_API.) for more information.</span></span>

#### <a name="how-requests-are-resolved"></a><span data-ttu-id="312bf-200">İsteklerin çözümlenmesi</span><span class="sxs-lookup"><span data-stu-id="312bf-200">How requests are resolved</span></span>

<span data-ttu-id="312bf-201">Yukarıda açıklandığı gibi, varsayılan hizmet çalışanı bir *ön uç* stratejisi kullanır, yani kullanılabilir olduğunda önbelleğe alınmış içeriğe hizmet vermeye çalışır.</span><span class="sxs-lookup"><span data-stu-id="312bf-201">As described above, the default service worker uses a *cache-first* strategy, meaning that it tries to serve cached content when available.</span></span> <span data-ttu-id="312bf-202">Belirli bir URL için önbelleğe alınmış içerik yoksa (örneğin, bir arka uç API 'sinden veri istenirken), hizmet çalışanı normal bir ağ isteğine geri döner ve bu da sunucu ulaşılabilir olduğunda yalnızca başarılı olabilir.</span><span class="sxs-lookup"><span data-stu-id="312bf-202">If there is no content cached for a certain URL, for example when requesting data from a backend API, the service worker falls back on a regular network request which can only succeed if the server is reachable.</span></span> <span data-ttu-id="312bf-203">Bu mantık, *Service-Worker. yayınlanmış. js*içinde `onFetch` içinde uygulanır.</span><span class="sxs-lookup"><span data-stu-id="312bf-203">This logic is implemented inside `onFetch` within *service-worker.published.js*.</span></span>

<span data-ttu-id="312bf-204">Blazor bileşenleriniz arka uç API 'Lerinden veri talep etmek istiyorsa ve bu tür isteklerin ağ kullanım dışı olması nedeniyle başarısız olduğu durumlarda kolay bir kullanıcı deneyimi sağlamak istiyorsanız, bileşenleriniz dahilinde Logic uygulamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="312bf-204">If your Blazor components rely on requesting data from backend APIs, and you want to provide a friendly user experience in the case where such requests fail due to network unavailability, then you need to implement logic within your components.</span></span> <span data-ttu-id="312bf-205">Örneğin, `HttpClient` istekleri etrafında `try/catch` kullanın.</span><span class="sxs-lookup"><span data-stu-id="312bf-205">For example, use `try/catch` around `HttpClient` requests.</span></span>

#### <a name="support-server-rendered-pages"></a><span data-ttu-id="312bf-206">Sunucu tarafından işlenen sayfaları destekleme</span><span class="sxs-lookup"><span data-stu-id="312bf-206">Support server-rendered pages</span></span>

<span data-ttu-id="312bf-207">Kullanıcı uygulamanız için `/counter` veya başka bir ayrıntılı bağlantı gibi bir URL 'ye ilk kez gittiğinde ne olacağını düşünün.</span><span class="sxs-lookup"><span data-stu-id="312bf-207">Consider what happens when the user first navigates to a URL such as `/counter` or any other deep link into your application.</span></span> <span data-ttu-id="312bf-208">Bu durumlarda, `/counter`olarak önbelleğe alınmış içerik döndürmek istemezsiniz, ancak bunun yerine Blazor WebAssembly uygulamanızı başlatmak için tarayıcıya `/index.html` olarak önbelleğe alınmış içeriği yüklemesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="312bf-208">In these cases, you don't want to return content cached as `/counter`, but instead need the browser to load the content cached as `/index.html` to start up your Blazor WebAssembly application.</span></span> <span data-ttu-id="312bf-209">Bu ilk istekler, *gezinme* istekleri olarak bilinir (görüntüler/CSS/vb için *alt kaynak* istekleri veya API verileri için *Fetch/XHR* istekleri).</span><span class="sxs-lookup"><span data-stu-id="312bf-209">These initial requests are known as *navigation* requests (as opposed to *subresource* requests for images/CSS/etc, or *fetch/XHR* requests for API data).</span></span>

<span data-ttu-id="312bf-210">Varsayılan hizmet çalışanı, gezinti istekleri için özel durum mantığı içerir.</span><span class="sxs-lookup"><span data-stu-id="312bf-210">The default service worker contains special-case logic for navigation requests.</span></span> <span data-ttu-id="312bf-211">Bu, istenen URL 'den bağımsız olarak `/index.html`önbelleğe alınmış içeriği döndürerek çözer.</span><span class="sxs-lookup"><span data-stu-id="312bf-211">It resolves them by returning the cached content for `/index.html`, regardless of the requested URL.</span></span> <span data-ttu-id="312bf-212">Bu mantık, *Service-Worker. yayınlanmış. js*içindeki `onFetch` işlevinde uygulanır.</span><span class="sxs-lookup"><span data-stu-id="312bf-212">This logic is implemented in the `onFetch` function inside *service-worker.published.js*.</span></span>

<span data-ttu-id="312bf-213">Uygulamanızda sunucu tarafından işlenmiş HTML (ve önbellekten `/index.html` hizmet verme) döndürmesi gereken belirli URL 'Ler varsa, hizmet çalışanınızdaki mantığı düzenlemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="312bf-213">If your application has certain URLs that must return server-rendered HTML (and not serve `/index.html` from the cache), then you need to edit the logic in your service worker.</span></span> <span data-ttu-id="312bf-214">Örneğin, `/Identity/` içeren tüm URL 'Lerin sunucuya düzenli olarak yalnızca çevrimiçi istekler olarak işlenmesi gerekiyorsa, *Service-Worker. yayınlanmış. js* `onFetch` mantığını değiştirin.</span><span class="sxs-lookup"><span data-stu-id="312bf-214">For example, if all URLs containing `/Identity/` need to be handled as regular online-only requests to the server, then modify *service-worker.published.js* `onFetch` logic.</span></span> <span data-ttu-id="312bf-215">Aşağıdaki kodu bulun:</span><span class="sxs-lookup"><span data-stu-id="312bf-215">Locate the following code:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate';
```

<span data-ttu-id="312bf-216">Kodu aşağıdaki şekilde değiştirin:</span><span class="sxs-lookup"><span data-stu-id="312bf-216">Change the code to the following:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate'
    && !event.request.url.includes('/Identity/');
```

<span data-ttu-id="312bf-217">Bunu yapmazsanız, ağ bağlantısından bağımsız olarak, hizmet çalışanı bu tür URL 'Lerin isteklerini durdurur ve `/index.html`kullanarak çözer.</span><span class="sxs-lookup"><span data-stu-id="312bf-217">If you don't do this, then regardless of network connectivity, the service worker will intercept requests for such URLs and will resolve them using `/index.html`.</span></span>

#### <a name="control-asset-caching"></a><span data-ttu-id="312bf-218">Varlık önbelleğe alma denetimi</span><span class="sxs-lookup"><span data-stu-id="312bf-218">Control asset caching</span></span>

<span data-ttu-id="312bf-219">Projeniz `ServiceWorkerAssetsManifest`adlı bir MSBuild özelliği tanımlarsa, Blazorderleme araçları, belirtilen ada sahip bir hizmet çalışanı varlık bildirimi oluşturacaktır.</span><span class="sxs-lookup"><span data-stu-id="312bf-219">If your project defines an MSBuild property called `ServiceWorkerAssetsManifest`, then Blazor's build tooling will generate a service worker assets manifest with the specified name.</span></span> <span data-ttu-id="312bf-220">Varsayılan PWA şablonu, aşağıdakileri içeren bir proje dosyası üretir:</span><span class="sxs-lookup"><span data-stu-id="312bf-220">The default PWA template produces a project file containing the following:</span></span>

```xml
<ServiceWorkerAssetsManifest>service-worker-assets.js</ServiceWorkerAssetsManifest>
```

<span data-ttu-id="312bf-221">Dosya *Wwwroot* çıkış dizinine yerleştirilir, bu nedenle tarayıcı `/service-worker-assets.js`isteyerek bu dosyayı alabilir.</span><span class="sxs-lookup"><span data-stu-id="312bf-221">The file is placed in the *wwwroot* output directory, so the browser can retrieve this file by requesting `/service-worker-assets.js`.</span></span> <span data-ttu-id="312bf-222">İçeriği görmek için, bir metin düzenleyicisinde *Yourproject\bin\debug\netstandard2,\wwwroot\service-Worker-assets.js* ' yi açın.</span><span class="sxs-lookup"><span data-stu-id="312bf-222">To see the contents, open *YourProject\bin\Debug\netstandard2.1\wwwroot\service-worker-assets.js* in a text editor.</span></span> <span data-ttu-id="312bf-223">Ancak, her bir derlemede yeniden üretildiğinden dosyayı düzenlemeyin.</span><span class="sxs-lookup"><span data-stu-id="312bf-223">However, don't edit the file, as it will be regenerated on each build.</span></span>

<span data-ttu-id="312bf-224">Varsayılan olarak, bu bildirim şunları listeler:</span><span class="sxs-lookup"><span data-stu-id="312bf-224">By default, this manifest lists:</span></span>

* <span data-ttu-id="312bf-225">.NET derlemeleri ve .NET WebAssembly çalışma zamanı dosyaları gibi Blazoryönetilen tüm kaynaklar çevrimdışı çalışması için gereklidir</span><span class="sxs-lookup"><span data-stu-id="312bf-225">Any Blazor-managed resources such as .NET assemblies and the .NET WebAssembly runtime files needed to function offline</span></span>
* <span data-ttu-id="312bf-226">Görüntü, CSS dosyaları ve JavaScript dosyaları gibi *Wwwroot* dizininizde yayımlanacak tüm kaynaklar.</span><span class="sxs-lookup"><span data-stu-id="312bf-226">All resources that will be published in your *wwwroot* directory, such as images, CSS files, and JavaScript files.</span></span> <span data-ttu-id="312bf-227">Bu, dış projeler ve NuGet paketleri tarafından sağlanan statik Web varlıklarını içerir.</span><span class="sxs-lookup"><span data-stu-id="312bf-227">This includes static web assets supplied by external projects and NuGet packages.</span></span>

<span data-ttu-id="312bf-228">*Service-Worker. yayınlanmış. js*' de `onInstall` mantığı düzenleyerek, bu kaynakların hangisinin hizmet çalışanı tarafından alınacağını ve önbelleğe alınacağını denetleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="312bf-228">You can control which of these resources will be fetched and cached by the service worker by editing the logic in `onInstall` in *service-worker.published.js*.</span></span> <span data-ttu-id="312bf-229">Varsayılan olarak, *. html*, *. css*, *. js*, *.* TDA gibi tipik web dosya adı uzantılarına ve diğer bir deyişle Blazor webassembly ( *. dll*, *. pdb*) ile ilgili dosya türlerine göre eşleşen dosyaları alıp önbelleğe alacak.</span><span class="sxs-lookup"><span data-stu-id="312bf-229">By default, it will fetch and cache files matching typical web filename extensions such as *.html*, *.css*, *.js*, *.wasm*, and others, plus file types specific to Blazor WebAssembly (*.dll*, *.pdb*).</span></span>

<span data-ttu-id="312bf-230">*Wwwroot* dizininizde bulunmayan ek kaynakları eklemek istiyorsanız, ek MSBuild ItemGroup girişleri tanımlayarak bunu yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="312bf-230">If you want to include additional resources that aren't present in your *wwwroot* directory, you can do so by defining extra MSBuild itemgroup entries.</span></span> <span data-ttu-id="312bf-231">Örneğin, proje dosyanızda şunu ekleyin:</span><span class="sxs-lookup"><span data-stu-id="312bf-231">For example, in your project file, add:</span></span>

```xml
<ItemGroup>
    <ServiceWorkerAssetsManifestItem
        Include="MyDirectory\AnotherFile.json"
        RelativePath="MyDirectory\AnotherFile.json"
        AssetUrl="files/AnotherFile.json" />
</ItemGroup>
```

<span data-ttu-id="312bf-232">`AssetUrl` meta verileri, tarayıcının önbelleğe kaynağı getirilirken kullanması gereken temel göreli URL 'YI belirtir.</span><span class="sxs-lookup"><span data-stu-id="312bf-232">The `AssetUrl` metadata specifies the base-relative URL that the browser should use when fetching the resource to cache.</span></span> <span data-ttu-id="312bf-233">Bu, diskteki özgün kaynak dosya adından bağımsız olabilir.</span><span class="sxs-lookup"><span data-stu-id="312bf-233">This can be independent of its original source file name on disk.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="312bf-234">`ServiceWorkerAssetsManifestItem` eklemek dosyanın *Wwwroot* dizininizde yayımlanmasına neden olmaz.</span><span class="sxs-lookup"><span data-stu-id="312bf-234">Adding a `ServiceWorkerAssetsManifestItem` does not cause the file to be published in your *wwwroot* directory.</span></span> <span data-ttu-id="312bf-235">Yayımlama çıktılarınızı ayrı ayrı denetlemek sizin için.</span><span class="sxs-lookup"><span data-stu-id="312bf-235">It up to you to control your publish output separately.</span></span> <span data-ttu-id="312bf-236">`ServiceWorkerAssetsManifestItem`, hizmet çalışanı varlıkları bildiriminde yalnızca ek bir girdinin görünmesine neden olur.</span><span class="sxs-lookup"><span data-stu-id="312bf-236">The `ServiceWorkerAssetsManifestItem` only causes an additional entry to appear in the service worker assets manifest.</span></span>

## <a name="push-notifications"></a><span data-ttu-id="312bf-237">Anında iletme bildirimleri</span><span class="sxs-lookup"><span data-stu-id="312bf-237">Push notifications</span></span>

<span data-ttu-id="312bf-238">Diğer herhangi bir PWA gibi, bir Blazor WebAssembly PWA, bir arka uç sunucusundan anında iletme bildirimleri alabilir.</span><span class="sxs-lookup"><span data-stu-id="312bf-238">Like any other PWA, a Blazor WebAssembly PWA can receive push notifications from a backend server.</span></span> <span data-ttu-id="312bf-239">Sunucunuz, Kullanıcı etkin bir şekilde kullanmadığınız durumlarda bile (örneğin, farklı bir Kullanıcı ilgili olabilecek bir işlem gerçekleştirdiğinde) bunları dilediğiniz zaman gönderebilir.</span><span class="sxs-lookup"><span data-stu-id="312bf-239">Your server can send these at any time, even when the user is not actively using your application (for example, when a different user performs an action that may be relevant).</span></span>

<span data-ttu-id="312bf-240">Anında iletme bildirimi gönderme mekanizması, herhangi bir teknolojiyi kullanan arka uç sunucu tarafından uygulandığından, Blazor WebAssembly ' den tamamen bağımsızdır.</span><span class="sxs-lookup"><span data-stu-id="312bf-240">The mechanism for sending a push notification is entirely independent of Blazor WebAssembly, since it's implemented by the backend server which can use any technology.</span></span> <span data-ttu-id="312bf-241">Bir ASP.NET Core sunucusundan anında iletme bildirimleri göndermek istiyorsanız, bu, güçlendirme, [pizza Atölyesi Workshop içindeki şuna benzer bir teknik kullanmayı](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications)göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="312bf-241">If you want to send push notifications from an ASP.NET Core server, consider [using a technique similar to that in the Blazing Pizza workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications).</span></span>

<span data-ttu-id="312bf-242">İstemci üzerinde anında iletme bildirimi alma ve görüntüleme mekanizması, bir JavaScript dosyası olan hizmet çalışanında uygulandığından, Blazor WebAssembly ' den bağımsızdır.</span><span class="sxs-lookup"><span data-stu-id="312bf-242">The mechanism for receiving and displaying a push notification on the client is also independent of Blazor WebAssembly, since it's implemented in the service worker, which is a JavaScript file.</span></span> <span data-ttu-id="312bf-243">Örnek olarak, daha sonra, daha önce [kullanılan pizza za ve ' de kullanılan yaklaşımı](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications)görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="312bf-243">As an example, you can again see [the approach used in the Blazing Pizza workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications).</span></span>

## <a name="caveats-for-offline-pwas"></a><span data-ttu-id="312bf-244">Çevrimdışı PDI uyarıları</span><span class="sxs-lookup"><span data-stu-id="312bf-244">Caveats for offline PWAs</span></span>

<span data-ttu-id="312bf-245">Tüm uygulamalar çevrimdışı kullanımı desteklemeyi denememelidir.</span><span class="sxs-lookup"><span data-stu-id="312bf-245">Not all applications should attempt to support offline use.</span></span> <span data-ttu-id="312bf-246">Her zaman ilgili olmayan önemli karmaşıklıklar ekler.</span><span class="sxs-lookup"><span data-stu-id="312bf-246">It adds significant complexity, while not always being relevant.</span></span>

<span data-ttu-id="312bf-247">Çevrimdışı destek genellikle ilgilidir:</span><span class="sxs-lookup"><span data-stu-id="312bf-247">Offline support is usually relevant only:</span></span>

* <span data-ttu-id="312bf-248">Birincil veri depoluizin tarayıcıya yereldir.</span><span class="sxs-lookup"><span data-stu-id="312bf-248">If your primary data store is local to the browser.</span></span> <span data-ttu-id="312bf-249">Örneğin, `localStorage` veya [IndexedDB](https://developer.mozilla.org/docs/Web/API/IndexedDB_API)'de veri depolayan bir [IoT](https://en.wikipedia.org/wiki/Internet_of_things) cihazı için bir kullanıcı arabirimi oluştururken.</span><span class="sxs-lookup"><span data-stu-id="312bf-249">For example, when building a UI for an [IoT](https://en.wikipedia.org/wiki/Internet_of_things) device that stores data in `localStorage` or [IndexedDB](https://developer.mozilla.org/docs/Web/API/IndexedDB_API).</span></span>

* <span data-ttu-id="312bf-250">Her kullanıcıyla ilgili arka uç API verilerini getirmek ve önbelleğe almak için önemli çalışmalar yaparsanız, çevrimdışı olarak gezinmeleri gerekir.</span><span class="sxs-lookup"><span data-stu-id="312bf-250">If you do significant work to fetch and cache the backend API data relevant to each user, so they can navigate through it offline.</span></span> <span data-ttu-id="312bf-251">Düzenlemesini destekliyorsa, değişiklikleri izlemek ve arka uca eşitlemek için bir sistem oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="312bf-251">If you support editing, you will also need to build a system for tracking changes and synchronizing them with the backend.</span></span>

* <span data-ttu-id="312bf-252">Amacınız, uygulamanın ağ koşullarından bağımsız olarak hemen yüklenmesi durumunda olduğundan emin olmaktır.</span><span class="sxs-lookup"><span data-stu-id="312bf-252">If your goal is to guarantee the application loads immediately regardless of network conditions.</span></span> <span data-ttu-id="312bf-253">Daha sonra isteklerin ilerlemesini göstermek için arka uç API 'SI isteklerinde uygun bir kullanıcı deneyimi uygulamanız gerekir ve ağ KULLANILAMAMASINDAN dolayı başarısız olduklarında düzgün bir şekilde davranır.</span><span class="sxs-lookup"><span data-stu-id="312bf-253">You will then need to implement a suitable user experience around backend API requests to show the progress of requests and behave gracefully when they fail due to network unavailability.</span></span>

<span data-ttu-id="312bf-254">Ayrıca, çevrimdışı yetenekli PWAs 'ların bir dizi ek karmaşıklıklarla ilgilenmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="312bf-254">Additionally, offline-capable PWAs need to deal with a range of extra complications.</span></span> <span data-ttu-id="312bf-255">Geliştiriciler aşağıdaki uyarılarla dikkatli bir şekilde bilgi sağlamalıdır.</span><span class="sxs-lookup"><span data-stu-id="312bf-255">Developers should carefully familiarize themselves with the following caveats.</span></span>

### <a name="offline-support-only-when-published"></a><span data-ttu-id="312bf-256">Yalnızca yayımlandığında çevrimdışı destek</span><span class="sxs-lookup"><span data-stu-id="312bf-256">Offline support only when published</span></span>

Blazor<span data-ttu-id="312bf-257">PWA şablonu, yalnızca yayımlandığında çevrimdışı desteğe izin vermez.</span><span class="sxs-lookup"><span data-stu-id="312bf-257">'s PWA template enables offline support only when published.</span></span> <span data-ttu-id="312bf-258">Bunun nedeni, geliştirme sırasında genellikle her bir değişikliğin bir arka plan güncelleştirme işlemine geçmeden hemen tarayıcıda yansıtıldığını görmek isteyeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="312bf-258">This is because, during development, you typically want to see each change reflected immediately in the browser, without going through a background update process.</span></span>

<span data-ttu-id="312bf-259">Bu nedenle, çevrimdışı özellikli bir uygulama oluştururken uygulamanızı geliştirme modunda test etmek yeterli değildir.</span><span class="sxs-lookup"><span data-stu-id="312bf-259">Therefore when building an offline-capable application, it's not enough to test your application in development mode.</span></span> <span data-ttu-id="312bf-260">Farklı ağ koşullarına nasıl yanıt vereceğini anlamak için uygulamanızı Yayımlanma durumunda test etmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="312bf-260">You must test your application in its published state to understand how it will respond to differing network conditions.</span></span>

### <a name="update-completion-after-user-navigation-away-from-app"></a><span data-ttu-id="312bf-261">Uygulamadan sonra Kullanıcı gezindikten sonra tamamlamayı Güncelleştir</span><span class="sxs-lookup"><span data-stu-id="312bf-261">Update completion after user navigation away from app</span></span>

<span data-ttu-id="312bf-262">Kullanıcılar uygulamanızdan tüm sekmelerde gezinene kadar güncelleştirmeler tamamlanmaz.</span><span class="sxs-lookup"><span data-stu-id="312bf-262">Updates don't complete until the user has navigated away from your application in all tabs.</span></span> <span data-ttu-id="312bf-263">[Arka plan güncelleştirmelerinde](#background-updates)açıklandığı gibi, uygulamanıza bir güncelleştirme dağıttıktan sonra, tarayıcı güncelleştirilmiş hizmet çalışanı dosyalarını getirip güncelleştirme işlemini başlatır.</span><span class="sxs-lookup"><span data-stu-id="312bf-263">As explained in [Background updates](#background-updates), after you deploy an update to your application, the browser will fetch the updated service worker files and begin an update process.</span></span>

<span data-ttu-id="312bf-264">Birçok geliştirici, bu güncelleştirme tamamlandığında bile Kullanıcı tüm sekmelerde gezinene kadar **etkili olmaz.**</span><span class="sxs-lookup"><span data-stu-id="312bf-264">What surprises many developers is that, even when this update completes, it does **not** take effect until the user has navigated away in all tabs.</span></span> <span data-ttu-id="312bf-265">Uygulamanızı görüntüleyen tek sekme olsa bile, uygulamanızı görüntüleyen sekmeyi yenilemek yeterli **değildir** .</span><span class="sxs-lookup"><span data-stu-id="312bf-265">It is **not** sufficient to refresh the tab displaying your application, even if it's the only tab displaying your application.</span></span> <span data-ttu-id="312bf-266">Uygulamanız tamamen kapanana kadar, yeni hizmet çalışanı "etkinleştirilmesi bekleniyor" durumunda kalır.</span><span class="sxs-lookup"><span data-stu-id="312bf-266">Until your application is completely closed, the new service worker will remain in a "waiting to activate" status.</span></span> <span data-ttu-id="312bf-267">**Bu, Blazorözgü değildir, ancak standart bir Web platformu davranışıdır.**</span><span class="sxs-lookup"><span data-stu-id="312bf-267">**This is not specific to Blazor, but rather is a standard web platform behavior.**</span></span>

<span data-ttu-id="312bf-268">Bu, yaygın olarak çalışan geliştiricilerin hizmet çalışanlarına veya Çevrimdışı önbelleğe alınmış kaynaklara yönelik güncelleştirmeleri test kurmaya çalışıyor.</span><span class="sxs-lookup"><span data-stu-id="312bf-268">This commonly troubles developers who are trying to test updates to their service worker or offline cached resources.</span></span> <span data-ttu-id="312bf-269">Tarayıcının geliştirme araçlarını iade ederseniz aşağıdakine benzer bir şey görebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="312bf-269">If you check in the browser's dev tools, you may see something like the following:</span></span>

![görüntü](https://user-images.githubusercontent.com/1101362/76226394-b93f7380-6215-11ea-8572-7d52afee2dd8.png)

<span data-ttu-id="312bf-271">"İstemciler" (örn. uygulamanızı görüntüleyen sekmeler veya pencereler) listesi boş olmadığı sürece, çalışan beklemeye devam eder.</span><span class="sxs-lookup"><span data-stu-id="312bf-271">For as long as the list of "clients" (i.e., tabs or windows displaying your application) is nonempty, the worker will continue waiting.</span></span> <span data-ttu-id="312bf-272">Bu nedenle, hizmet çalışanları bunu, tüm kaynakların aynı atomik önbellekten getirilme garantisi sağlar.</span><span class="sxs-lookup"><span data-stu-id="312bf-272">The reason service workers do this is to guarantee consistency, i.e., that all resources are fetched from the same atomic cache.</span></span>

<span data-ttu-id="312bf-273">Değişiklikleri test ederken, yukarıdaki ekran görüntüsünde gösterildiği gibi "Skipbeklediği" bağlantısına tıklamayı kullanışlı bulabilirsiniz ve sonra sayfayı yeniden yükleyin.</span><span class="sxs-lookup"><span data-stu-id="312bf-273">When testing changes, you may find it convenient to click the "skipWaiting" link as shown in the screenshot above, then reload the page.</span></span> <span data-ttu-id="312bf-274">İsterseniz, ["bekleme" aşamasını atlayıp güncelleştirme üzerinde hemen etkinleştirmek](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase)üzere hizmet çalışanınızı kodlayarak tüm kullanıcılar için bunu otomatikleştirin.</span><span class="sxs-lookup"><span data-stu-id="312bf-274">If you want, you can automate this for all users by coding your service worker to [skip the "waiting" phase and immediately activate on update](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase).</span></span> <span data-ttu-id="312bf-275">Ancak bunu yaparsanız, kaynakların her zaman aynı önbellek örneğinden sürekli olarak getirilme garantisi vermiş olursunuz.</span><span class="sxs-lookup"><span data-stu-id="312bf-275">However if you do this, you are giving up the guarantee that resources are always fetched consistently from the same cache instance.</span></span>

### <a name="users-may-run-any-historical-version-of-the-app"></a><span data-ttu-id="312bf-276">Kullanıcılar uygulamanın geçmiş bir sürümünü çalıştırabilir</span><span class="sxs-lookup"><span data-stu-id="312bf-276">Users may run any historical version of the app</span></span>

<span data-ttu-id="312bf-277">Web geliştiricileri habitually, kullanıcıların geleneksel Web Dağıtım modelinde bu yana, Web uygulamalarının yalnızca en son dağıtılan sürümünü çalıştırmasını bekler.</span><span class="sxs-lookup"><span data-stu-id="312bf-277">Web developers habitually expect that users will only run the latest deployed version of their web application, since that's normal within the traditional web distribution model.</span></span> <span data-ttu-id="312bf-278">Ancak, çevrimdışı bir ilk PWA, kullanıcıların en son sürümü çalıştırması gereken yerel bir mobil uygulamaya daha fazla oturum sağlar.</span><span class="sxs-lookup"><span data-stu-id="312bf-278">However, an offline-first PWA is more akin to a native mobile app, where users are not necessarily running the latest version.</span></span>

<span data-ttu-id="312bf-279">[Arka plan güncelleştirmelerinde](#background-updates)açıklandığı gibi, uygulamanıza bir güncelleştirme dağıttıktan sonra, **mevcut olan her Kullanıcı en az bir daha ziyaret için daha önceki bir sürümü kullanmaya devam edecektir** (güncelleştirme arka planda yapıldığından ve Kullanıcı daha sonra uzaklaşana kadar etkinleştirilmemiş olduğundan).</span><span class="sxs-lookup"><span data-stu-id="312bf-279">As explained in [Background updates](#background-updates), after you deploy an update to your application, **each existing user will continue to use a previous version for at least one further visit** (because the update occurs in the background and isn't activated until the user then navigates away).</span></span> <span data-ttu-id="312bf-280">Ayrıca, kullanılmakta olan önceki sürüm, dağıttığınız bir önceki sürüm değildir; kullanıcının bir güncelleştirmeyi en son ne zaman tamamladığına bağlı *olarak geçmiş sürümü olabilir.*</span><span class="sxs-lookup"><span data-stu-id="312bf-280">Plus, the previous version being used isn't necessarily the previous one you deployed - it can be *any* historical version, depending on when the user last completed an update.</span></span>

<span data-ttu-id="312bf-281">Uygulamanızın ön uç ve arka uç bölümleri API istekleri için şema hakkında anlaşma gerektiriyorsa bu bir sorun olabilir.</span><span class="sxs-lookup"><span data-stu-id="312bf-281">This can be an issue if the frontend and backend parts of your application require agreement about the schema for API requests.</span></span> <span data-ttu-id="312bf-282">Tüm kullanıcıların yükseltildiğinden emin olana veya en azından kullanıcıların uygulamanın uyumsuz eski sürümlerini kullanmasını engellemek için geriye dönük olarak uyumsuz API şema değişikliklerini dağıtmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="312bf-282">You must not deploy backward-incompatible API schema changes until you can be sure that all users have upgraded, or at least block users from using incompatible older versions of the app.</span></span> <span data-ttu-id="312bf-283">Bu, yerel bir mobil uygulama gibidir.</span><span class="sxs-lookup"><span data-stu-id="312bf-283">This is just like a native mobile app.</span></span> <span data-ttu-id="312bf-284">Sunucu API 'Lerinde bir son değişiklik dağıtırsanız, istemci uygulaması henüz güncelleştirilmemiş kişiler için bozulur.</span><span class="sxs-lookup"><span data-stu-id="312bf-284">If you deploy a breaking change in server APIs, the client app will be broken for people who haven't yet updated.</span></span>

<span data-ttu-id="312bf-285">Mümkünse, arka uç API 'lerinize son değişiklikleri dağıtmayın.</span><span class="sxs-lookup"><span data-stu-id="312bf-285">If possible, don't deploy breaking changes to your backend APIs.</span></span> <span data-ttu-id="312bf-286">Ancak bunu yapmanız gerekiyorsa, uygulamanın güncel olup olmadığını ve kullanım dışı olduğunu anlamak için [`ServiceWorkerRegistration`gibi standart hizmet çalışanı API 'lerini](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration) kullanmayı göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="312bf-286">But if you must do so, consider using [standard Service Worker APIs such as `ServiceWorkerRegistration`](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration) to determine whether the application is up-to-date, and if not, to prevent usage.</span></span>

### <a name="interference-with-server-rendered-pages"></a><span data-ttu-id="312bf-287">Sunucu tarafından işlenmiş sayfalarla girişim</span><span class="sxs-lookup"><span data-stu-id="312bf-287">Interference with server-rendered pages</span></span>

<span data-ttu-id="312bf-288">[Yukarıda açıklandığı gibi](#support-server-rendered-pages), hizmet çalışanının tüm gezinti istekleri için `/index.html` içerik döndürme davranışını atlamak istiyorsanız, hizmet çalışanınızdaki mantığı düzenlemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="312bf-288">[As described above](#support-server-rendered-pages), if you want to bypass the service worker's behavior of returning `/index.html` contents for all navigation requests, you need to edit the logic in your service worker.</span></span>

### <a name="all-service-worker-asset-manifest-contents-are-cached-by-default"></a><span data-ttu-id="312bf-289">Tüm hizmet çalışanı varlık bildirimi içerikleri varsayılan olarak önbelleğe alınır</span><span class="sxs-lookup"><span data-stu-id="312bf-289">All service worker asset manifest contents are cached by default</span></span>

<span data-ttu-id="312bf-290">[Yukarıda açıklandığı gibi](#control-asset-caching), *Service-Worker-assets. js* dosyası derleme sırasında oluşturulur ve hizmet çalışanının getirme ve önbelleğe alma gereken tüm varlıkları listeler.</span><span class="sxs-lookup"><span data-stu-id="312bf-290">[As described above](#control-asset-caching), the file *service-worker-assets.js* is generated during build and lists all assets the service worker should fetch and cache.</span></span>

<span data-ttu-id="312bf-291">Bu liste varsayılan olarak *Wwwroot* 'ya yayılan her şeyi (dış paketler ve projeler tarafından sağlanan içerikler dahil) içerdiğinden, orada çok fazla içerik yerleştirmemeye dikkat etmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="312bf-291">Since this list by default includes everything emitted to *wwwroot* (including content supplied by external packages and projects), you must be careful not to put too much content there.</span></span> <span data-ttu-id="312bf-292">Örneğin, *Wwwroot* dizininiz milyonlarca görüntü içeriyorsa, hizmet çalışanı bunları getirmeyi ve önbelleğe almaya çalışır ve çok fazla bant genişliği ve büyük olasılıkla başarıyla tamamlanmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="312bf-292">If for example your *wwwroot* directory contains millions of images, the service worker would try to fetch and cache them all, consuming excessive bandwidth and most likely not completing successfully.</span></span>

<span data-ttu-id="312bf-293">*Service-Worker. yayınlanmış. js*' de `onInstall` işlevini düzenleyerek, bildirim içeriğinin hangi alt kümesinin alınacağını ve önbelleğe alınacağını denetlemek için rastgele mantık uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="312bf-293">You can implement arbitrary logic to control which subset of the manifest's contents should be fetched and cached by editing the `onInstall` function in *service-worker.published.js*.</span></span>

### <a name="interaction-with-authentication"></a><span data-ttu-id="312bf-294">Kimlik doğrulamasıyla etkileşim</span><span class="sxs-lookup"><span data-stu-id="312bf-294">Interaction with authentication</span></span>

<span data-ttu-id="312bf-295">PWA şablonu seçeneğini kimlik doğrulama seçenekleriyle birlikte kullanmak mümkündür.</span><span class="sxs-lookup"><span data-stu-id="312bf-295">It's possible to use the PWA template option in conjunction with the authentication options.</span></span> <span data-ttu-id="312bf-296">Çevrimdışı özellikli bir PWA, kullanıcının ağ bağlantısı olduğunda kimlik doğrulamasını da destekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="312bf-296">An offline-capable PWA can also support authentication when the user has network connectivity.</span></span>

<span data-ttu-id="312bf-297">Ancak, bir kullanıcının ağ bağlantısı yoksa, kimlik doğrulaması yapamaz veya erişim belirteçleri edinemeyecektir.</span><span class="sxs-lookup"><span data-stu-id="312bf-297">However, when a user does not have network connectivity, they will not be able to authenticate or obtain access tokens.</span></span> <span data-ttu-id="312bf-298">"Oturum açma" sayfası, varsayılan olarak "ağ hatası" bildiren bir ileti görüntüler.</span><span class="sxs-lookup"><span data-stu-id="312bf-298">Attempting to visit the "login" page will by default display a message saying "network error".</span></span>

<span data-ttu-id="312bf-299">Bu nedenle, kullanıcının, erişim belirteçlerini doğrulamaya veya almaya veya en azından bu durumlarda düzgün bir şekilde başarısız olmasına gerek kalmadan çevrimdışıyken yararlı şeyler yapmasını sağlayan bir kullanıcı arabirimi akışı tasarlayabilmenizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="312bf-299">As such it's your job to design a UI flow that lets the user do useful things while offline without attempting to authenticate or obtain access tokens, or at least failing in a graceful way in those cases.</span></span> <span data-ttu-id="312bf-300">Uygulamanızda bu mümkün değilse, çevrimdışı desteği etkinleştirmek istemeyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="312bf-300">If this isn't possible in your application, you might not want to enable offline support.</span></span>
