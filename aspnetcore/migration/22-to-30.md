---
title: 2\.2-3.0 Önizleme ASP.NET çekirdek geçirme
author: tdykstra
description: ASP.NET Core 3. 0'için bir ASP.NET Core 2.2 proje geçirmeyi öğrenin.
ms.author: tdykstra
ms.custom: mvc
ms.date: 06/17/2019
uid: migration/22-to-30
ms.openlocfilehash: abd31fa8ed27af230f347608f3e60f855a46b908
ms.sourcegitcommit: 28a2874765cefe9eaa068dceb989a978ba2096aa
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 06/17/2019
ms.locfileid: "67167118"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>ASP.NET Core-2.2 3.0 geçiş

Tarafından [Scott Addie](https://github.com/scottaddie) ve [Rick Anderson](https://twitter.com/RickAndMSFT)

Bu makalede, ASP.NET Core 3.0 için mevcut bir ASP.NET Core 2.2 projeyi güncelleştirin açıklanmaktadır.

[!INCLUDE[](~/includes/net-core-prereqs-all-3.0.md)]

## <a name="update-the-project-file"></a>Proje dosyasını güncelleştirme

* Ayarlama [hedef çerçeve adı (TFM)](/dotnet/standard/frameworks#referring-to-frameworks) için `netcoreapp3.0`:

  ```xml
  <TargetFramework>netcoreapp3.0</TargetFramework>
  ```

* Kaldırmak `<PackageReference>` için [Microsoft.AspNetCore.All](xref:fundamentals/metapackage) veya [Microsoft.AspNetCore.App](xref:fundamentals/metapackage-app) metapackage.

* Güncelleştirme `Version` kalan üzerinde öznitelik `<PackageReference>` için öğeleri `Microsoft.AspNetCore.*` geçerli Önizleme paketleri (örneğin, `3.0.0-preview5-19227-01`).

  Bir paketin hiçbir 3.0 sürümü varsa, paket 3. 0'kullanım dışı bırakılmış. Bu paketler birçoğu parçası olan `Microsoft.AspNetCore.App` ve ayrı ayrı başvurulan olmamalıdır. 3\. 0'artık üretilen paketlerin ön bir listesi için bkz [3.0 paylaşılan çerçeve derlemeleri için paketleri oluşturmayı durdur (aspnet/AspNetCore #3756)](https://github.com/aspnet/AspNetCore/issues/3756). *Paylaşılan çerçeve* derlemeleri kümesidir ( *.dll* dosyaları) bu makinede yüklü ve tarafından başvurulan `Microsoft.AspNetCore.App`. Daha fazla bilgi için [paylaşılan çerçeve](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Birkaç önemli bileşeni için derlemeleri sıradan kaldırıldığını `Microsoft.AspNetCore.App` 3.0. Ekleme `<PackageReference>` listelenen paketlerinden API kullanıyorsanız, öğeleri [Microsoft.AspNetCore.App 3.0 uygulamasından kaldırılmakta olan derlemeleri (aspnet/AspNetCore #3755)](https://github.com/aspnet/AspNetCore/issues/3755).

  Kaldırılan bileşenlerinin örnekleri şunlardır:

  * `Microsoft.AspNet.WebApi.Client`
  * `Microsoft.EntityFrameworkCore`
  * `System.Data.SqlClient`

  İçinde sevkiyat derlemelerin listesini `Microsoft.AspNetCore.App` kesin olmayan ve önce 3.0 RTM değiştirmez.

  Aşağıdaki kodu göz önünde bulundurun:

  ```csharp
  var branches = await response.Content.ReadAsAsync<IEnumerable<GitHubBranch>>();
  ```

  `ReadAsAsync` Önceki kodda adlı bir yöntem dahil `Microsoft.AspNet.WebApi.Client`. Yükleme [System.NET.http.Formatting](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) 3.0 derleme sorunu gidermek için NuGet paketi.

* Ekleme [Json.NET Destek](#jsonnet-support).

* Projeleri için varsayılan değer [işlem içi barındırma modeli](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) ASP.NET Core 3.0 veya üzeri. İsteğe bağlı olarak kaldırabilir `<AspNetCoreHostingModel>` özellik değeri ise proje dosyasında `InProcess`.

## <a name="jsonnet-support"></a>Json.NET desteği

İşin bir parçası olarak [ASP.NET Core paylaşılan çerçeve geliştirmek](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), [Json.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) ASP.NET Core paylaşılan Framework'ten kaldırıldı.

ASP.NET Core 3.0 projesinde Json.NET kullanmak için:

* Paket başvurusu ekleme [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Güncelleştirme `Startup.ConfigureServices` çağrılacak `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  Json.NET ayarları çağrısında ayarlanabilir `AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>MVC hizmeti kaydı

3\.0 ASP.NET Core MVC senaryoları içine kaydetmek için yeni seçenekler ekler `Startup.ConfigureServices`.

Üç yeni üst düzey genişletme yöntemleri üzerinde MVC senaryoları için ilgili `IServiceCollection` kullanılabilir. Şablonları kullanmak yerine bu yeni yöntemler `UseMvc`. Ancak, `AddMvc` önceki sürümlerde olduğu gibi davranmaya devam eder.

Aşağıdaki örnek denetleyicileri ve API güvenlikle ilgili özellikler, ancak görünümleri veya sayfaları için destek ekler. Bu kodu API şablonu kullanır:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Aşağıdaki örnek denetleyicileri, API ile ilgili özellikler ve görünümleri, ancak değil sayfaları için destek ekler. Web uygulaması (MVC) şablonu, bu kod kullanır:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Aşağıdaki örnek, Razor sayfaları ve en az bir denetleyici desteği ekler. Web uygulaması şablonu, bu kod kullanır:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Yeni yöntemler de birleştirilebilir. Aşağıdaki örnek çağırmakla eşdeğerdir `AddMvc` ASP.NET Core 2.2 içinde: 

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
    services.AddRazorPages();
}
```

## <a name="update-routing-startup-code"></a>Yönlendirme başlatma kodunu güncelleştirme

Bir uygulama çağırırsa `UseMvc` veya `UseSignalR`, uygulamaya geçmeleri [uç noktası yönlendirme](xref:fundamentals/routing) mümkünse. MVC önceki sürümleriyle uyumluluk uç noktası yönlendirme geliştirmek için biz bazı değişiklikler ASP.NET Core 2.2 içinde sunulan URL üretimi içinde geri. 2\.2 içinde uç noktası yönlendirme kullanarak sorunları yaşadı, geliştirmeleri aşağıdaki istisnalar içinde ASP.NET Core 3.0 beklediğiniz:

* Uygulama uyguluyorsa `IRouter` veya devralınan `Route`, şu anda geçiş önlemek isteyebilirsiniz. Geribildirim, [IRouter tabanlı uygulamaları uç noktası yönlendirme üzerine geçirmeyi planladığınız](https://github.com/aspnet/AspNetCore/issues/4221).

* Uygulamayı doğrudan erişiyorsa `RouteData.Routers` MVC içinde şu anda geçiş önlemek isteyebilirsiniz. Geribildirim, [RouteData.Routers kullanarak geçiş Kılavuzu](https://github.com/aspnet/AspNetCore/issues/9148).

Uç noktası yönlendirme destekleyen aynı yol deseni sözdizimi ve rota düzeni özellikleri yazma `IRouter`. Uç noktası yönlendirme destekler `IRouteContraint`. Uç noktası yönlendirme destekler `[Route]`, `[HttpGet]`ve diğer MVC yönlendirme öznitelikleri.

Çoğu uygulama, yalnızca için `Startup` değişiklikler gerektirir.

### <a name="migrate-startupconfigure"></a>Startup.Configure geçirme

Genel öneriler:

* Ekleme `UseRouting`. 
* Uygulama çağırırsa `UseStaticFiles`, yerleştirin `UseStaticFiles` **önce** `UseRouting`.
* Uygulama kimlik doğrulama/yetkilendirme özellikleri gibi kullanıyorsa `AuthorizePage` veya `[Authorize]`, çağrı yapmak `UseAuthentication` ve `UseAuthorization` **sonra** `UseRouting`.
* Uygulama kullanıyorsa [CORS](xref:security/cors) gibi özellikleri `[EnableCors]`, yerleştirin `UseCors` sonraki.
* Değiştirin `UseMvc` veya `UseSignalR` ile `UseEndpoints`.

Aşağıdaki örneğidir `Startup.Configure` tipik bir ASP.NET Core 2.2 uygulamasında:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();
    
    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Önceki güncelleştirdikten sonra `Startup.Configure` kod:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();
    
    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();
    app.UseCors();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="security-middleware-guidance"></a>Güvenlik ara yazılım Kılavuzu

Yetkilendirme ve CORS desteği birleşik etrafında [ara yazılım](xref:fundamentals/middleware/index) yaklaşım. Bu, bu senaryolar arasında aynı ara yazılım ve işlevsellik kullanımına izin verir. Bu sürümde bir güncelleştirilmiş yetkilendirme ara yazılımı sağlanır ve MVC denetleyicileri tarafından kullanılan öznitelikler anlayabilmeniz CORS ara yazılımı geliştirilmiştir.

#### <a name="cors"></a>CORS

Daha önce CORS yapılandırma zor olabilir. Ara yazılım belirtildi kullanın, bazı durumlarda, ancak MVC filtreleri hedeflenen kullanılacak **olmadan** ara yazılım diğer kullanım örnekleri. ASP.NET Core 3.0 ile CORS gerektiren tüm uygulamaları dağıtımınızla birlikte uç noktası yönlendirme CORS ara yazılımı kullanmanızı öneririz. `UseCors` bir varsayılan ilke ile sağlanabilir ve `[EnableCors]` ve `[DisableCors]` öznitelikleri, varsayılan ilkesini geçersiz kılmak için kullanılabilir gerektiğinde. 

Aşağıdaki örnekte:

* CORS ile tüm uç noktalar için etkin `default` ilke adı.
* `MyController` Sınıf, CORS ile devre dışı bırakır `[DisableCors]` özniteliği.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default"); 

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Yetkilendirme

ASP.NET Core önceki sürümlerinde, yetkilendirme Destek aracılığıyla sağlanan `[Authorize]` özniteliği. Yetkilendirme ara yazılımı kullanılabilir değildi. ASP.NET Core 3. 0'yetkilendirme ara yazılım gereklidir. ASP.NET Core yetkilendirme ara yazılımı yerleştirme öneririz (`UseAuthorization`) hemen sonra `UseAuthentication`. Yetkilendirme ara yazılımı de geçersiz kılınabilir bir varsayılan ilkesi ile yapılandırılabilir.

ASP.NET Core 3.0 veya sonraki sürümlerde, `UseAuthorization` çağrılma yeri `Startup.Configure`, şunları `HomeController` kullanıcı olarak oturum açtıysanız gerektirir:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Uygulama kullanıyorsa bir `AuthorizeFilter` mvc'de genel filtre olarak, bir ilke sağlamak üzere kodu yeniden düzenleme olan öneririz `UseAuthorization` ara yazılım.

Aşağıdaki örnekte, tüm uygulanması için özel bir ilke isteklerinin ne zaman `UseAuthorization` denir ve `HomeController` uygulamaya oturum açılması kullanıcı olmadan erişim sağlar:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization(new AuthorizationPolicyBuilder().Build()));

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Yetkilendirme ara yazılımı tarafından yetkilendirme belirli bilgisine sahip framework çalışır. Örneğin, [sistem durumu denetimleri](xref:host-and-deploy/health-checks) özel yetkilendirme bilgisi var, ancak sistem durumu denetimleri, ara yazılım tarafından uygulanan yapılandırılabilir yetkilendirme ilkesi olabilir.

Aşağıdaki örnekte, `UseAuthorization` yetkilendirme bir varsayılan ilke olmadan işler ancak `/healthz` sistem durumu onay uç noktası gerektirir, kullanıcı `admin` rolü: 

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Koruma için bazı senaryolar uygulanır. `UseEndpoint` Ara yazılım bir yetkilendirme veya CORS ilkesi eksik ara yazılım nedeniyle atlandı bir özel durum oluşturur. Devam eden hatalı yapılandırma hakkında ek geri bildirim sağlamak için Çözümleyicisi desteği.

### <a name="migrate-signalr"></a>SignalR geçirme

SignalR hub'ları şimdi eşlemesi içinde yer alan `UseEndpoints`. 

Her hub'la harita `MapHub`. Önceki sürümlerinde olduğu gibi her hub açıkça listelenir.

Aşağıdaki örnekte, destek `ChatHub` SignalR hub'ı eklenir:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

### <a name="migrate-mvc-controllers"></a>MVC denetleyicileri geçirme

Denetleyicileri artık eşlemesi içinde yer alan `UseEndpoints`. 

Ekleme `MapControllers` uygulama öznitelik yönlendirme kullanıyorsa. ASP.NET Core 3.0 veya daha sonra birçok çerçeveler için destek yönlendirme içerdiğinden, öznitelik yönlendirilen denetleyicileri ekleme kabul etme. 

Aşağıdakileri değiştirin:

* `MapRoute` ile `MapControllerRoute`
* `MapAreaRoute` ile `MapAreaControllerRoute`

Daha fazlasını MVC desteği artık yönlendirme içerdiğinden, bu yöntemlerin yapabileceklerini açıkça durum yapmak için terminoloji değişti. Geleneksel yolları gibi `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` eklenen sırayla uygulanır. Daha özel yollar (örneğin, bir alan için rotalar) ilk yerleştirin.

Aşağıdaki örnekte:

* `MapControllers` öznitelik yönlendirilen denetleyicileri için destek ekler.
* `MapAreaControllerRoute` bir alanı denetleyicileri için geleneksel bir rota ekler.
* `MapControllerRoute` denetleyicileri için geleneksel bir rota ekler.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin", 
            "admin", 
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="migrate-razor-pages"></a>Razor sayfaları geçirme

Razor sayfaları artık eşlemesi içinde yer alan `UseEndpoints`.

Ekleme `MapRazorPages` uygulama Razor sayfaları kullanıyorsa. Uç noktası yönlendirme birçok çerçeveler için destek içerdiğinden, Razor sayfaları ekleme katılımı sunulmuştur.

Aşağıdaki örnekte, `MapRazorPages` Razor sayfaları için destek ekler:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>MVC uç noktası yönlendirme olmadan kullanın

MVC ile kullanma `UseMvc` veya `UseMvcWithDefaultRoute` açık bir ASP.NET Core 3. 0'gerektirir katılımı içinde `Startup.ConfigureServices`. Bu yetkilendirme ve CORS ara yazılımı başlatma sırasında güvenebilirsiniz olmadığını MVC bilmesi gerektiğinden bu gereklidir. Bir çözümleyici, desteklenmeyen bir yapılandırma kullanmayı deneyip denemeyeceğini uygulama konusunda uyarır sağlanır.

Uygulama eski gerektiriyorsa `IRouter` desteği, devre dışı `EnableEndpointRouting` aşağıdakilerden herhangi birini kullanarak yaklaşıyor içinde `Startup.ConfigureServices`:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);

```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="migrate-health-checks"></a>Sistem durumu denetimleri geçirme

Sistem durumu denetimleri olarak kullanılabilir bir *Yönlendirici donanımlar* uç noktası yönlendirme.

Ekleme `MapHealthChecks` sistem durumu uç nokta yönlendirme ile denetler. `MapHealthChecks` Yöntemi benzer bağımsız değişkenleri kabul `UseHealthChecks`. Kullanmanın avantajı `MapHealthChecks` üzerinden `UseHealthChecks` yetkilendirme uygulamak ve eşleşen ilke üzerinde daha ayrıntılı denetime sahip olmasını özelliğidir. 

Aşağıdaki örnekte, `MapHealthChecks` için sistem durumu denetimi uç noktada adlı `/healthz`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder WebHostBuilder yerini alır.

ASP.NET Core 3.0 şablonlarını kullanma [genel ana bilgisayar](xref:fundamentals/host/generic-host). Önceki sürümlerinde kullanılan [Web ana bilgisayarı](xref:fundamentals/host/web-host). Aşağıdaki kod oluşturulan ASP.NET Core 3.0 şablonunu gösterir `Program` sınıfı:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Aşağıdaki kod, ASP.NET Core Şablonu oluşturulan 2.2 göstermektedir `Program` sınıfı:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> 3. 0'kalır ve türü `webBuilder` Yukarıdaki kod örneğinde görülen. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> gelecekteki bir sürümde kullanımdan ve yerine `HostBuilder`.

En önemli değişiklik `WebHostBuilder` için `HostBuilder` bulunduğu [bağımlılık ekleme (dı)](xref:fundamentals/dependency-injection). Kullanırken `HostBuilder`, yalnızca ekleyebilir <xref:Microsoft.Extensions.Configuration.IConfiguration> ve <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> içine `Startup`'s Oluşturucusu. `HostBuilder` DI kısıtlamaları:

* Yalnızca bir kez oluşturulacak DI kapsayıcı etkinleştirin.
* Birden çok örneğini teklileri çözümleme gibi elde edilen nesne kullanım ömrü sorunlarını önler.

## <a name="update-signalr-code"></a>SignalR kodunu güncelleştirme

`System.Text.Json` Varsayılan Hub protokol istemci ve sunucu tarafından kullanılan artık olur.

İçinde `Startup.ConfigureServices`, çağrı `AddJsonProtocol` seri hale getirici seçeneklerini ayarlamak için.

**Sunucu:**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**İstemci:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Newtonsoft.Json için geçiş

Özelliklerini kullanıyorsanız, `Newtonsoft.Json` içinde desteklenmeyen `System.Text.Json`, geri geçiş yapabilirsiniz `Newtonsoft.Json`:

1. Yükleme [Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) NuGet paketi.
1. İstemcide, zincir bir `AddNewtonsoftJsonProtocol` yöntem çağrısını `HubConnectionBuilder` örneği:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. Sunucuda zincirleme bir `AddNewtonsoftJsonProtocol` yöntem çağrısını `AddSignalR` yöntem çağrısı `Startup.ConfigureServices`:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Çalışma zamanı derlemesi kabul et

3\. 0'çalışma zamanı derlemesi Tercihli bir senaryodur. Çalışma zamanı derlemesi etkinleştirmek için bkz: <xref:mvc/views/view-compilation#runtime-compilation>.
