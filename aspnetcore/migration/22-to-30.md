---
title: ASP.NET Core 2,2 ' den 3,0 ' e geçiş yapın
author: rick-anderson
description: ASP.NET Core 2,2 projesini ASP.NET Core 3,0 ' e geçirmeyi öğrenin.
ms.author: riande
ms.custom: mvc
ms.date: 10/08/2019
uid: migration/22-to-30
ms.openlocfilehash: e9a4fed88a7ed2d0347704987b3f1c2fede31ec3
ms.sourcegitcommit: 73a451e9a58ac7102f90b608d661d8c23dd9bbaf
ms.translationtype: HT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/08/2019
ms.locfileid: "72037506"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>ASP.NET Core 2,2 ' den 3,0 ' e geçiş yapın

[Scott Ade](https://github.com/scottaddie) ve [Rick Anderson](https://twitter.com/RickAndMSFT) tarafından

Bu makalede, mevcut bir ASP.NET Core 2,2 projesinin ASP.NET Core 3,0 ' e nasıl güncelleştirilmesi açıklanmaktadır.

## <a name="prerequisites"></a>Önkoşullar

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Mac için Visual Studio](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Global. JSON içinde .NET Core SDK sürümü güncelleştirme

Çözümünüz belirli bir .NET Core SDK sürümünü hedeflemek için bir [Global. JSON](/dotnet/core/tools/global-json) dosyası kullanıyorsa, `version` özelliğini makinenizde yüklü 3,0 sürümüne güncelleştirin:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Proje dosyasını güncelleştirme

### <a name="update-the-target-framework"></a>Hedef çerçeveyi güncelleştirme

ASP.NET Core 3,0 ve üzeri yalnızca .NET Core üzerinde çalışır. [Hedef Framework bilinen adını (tfd)](/dotnet/standard/frameworks) `netcoreapp3.0` olarak ayarlayın:

```xml
<TargetFramework>netcoreapp3.0</TargetFramework>
```

### <a name="remove-obsolete-package-references"></a>Kullanımdan kaldırılmış paket başvurularını kaldır

ASP.NET Core artık çok sayıda NuGet paket özelliği üremez. Bu paket başvuruları proje dosyasından kaldırılmalıdır. Artık üretilmeyen paketlerin tam listesini görmek için aşağıya bakın:

<details>
    <summary>Artık üretilmeyen paketlerin listesini genişletmek için buraya tıklayın</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.JwtBearer</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authentication.OpenIdConnect</li>
        <li>Microsoft.AspNetCore.Authorization</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Cryptography.Internal</li>
        <li>Microsoft.AspNetCore.Cryptography.KeyDerivation</li>
        <li>Microsoft.AspNetCore.DataProtection</li>
        <li>Microsoft.AspNetCore.DataProtection.Abstractions</li>
        <li>Microsoft.AspNetCore.DataProtection.Extensions</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.Http.Features</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.MiddlewareAnalysis</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.Extensions</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft.AspNetCore.SignalR</li>
        <li>Microsoft.AspNetCore.SignalR.Core</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net. http. Headers</li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Son değişiklikleri gözden geçir

[Son değişiklikleri gözden geçir](#break)

### <a name="framework-reference"></a>Framework başvurusu

Yukarıda listelenen paketlerden biri ile kullanılabilen ASP.NET Core Özellikleri, `Microsoft.AspNetCore.App` paylaşılan çerçevesinin bir parçası olarak kullanılabilir. *Paylaşılan çerçeve* , makinede yüklü olan ve bir çalışma zamanı bileşeni ve hedefleme paketi içeren derleme ( *. dll* dosyaları) kümesidir. Daha fazla bilgi için bkz. [paylaşılan çerçeve](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* @No__t-0 SDK 'sını hedefleyen projeler, `Microsoft.AspNetCore.App` çerçevesine örtülü olarak başvurur.

Bu projeler için ek başvuru gerekli değildir:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>
    ...
</Project>
```

* @No__t-0 veya `Microsoft.NET.Sdk.Razor` SDK ' yı hedefleyen projeler, `Microsoft.AspNetCore.App` ' e açık bir `FrameworkReference` eklemesi gerekir:

```xml
<Project Sdk="Microsoft.NET.Sdk.Razor">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>
    ...
</Project>
```

#### <a name="framework-dependent-builds-using-docker"></a>Docker kullanan çerçeveye bağımlı yapılar

ASP.NET Core [paylaşılan çerçeveye](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) bağlı bir paket kullanan konsol uygulamalarının çerçeveye bağımlı derlemeleri aşağıdaki çalışma zamanı hatasına verebilir:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App`, ASP.NET Core çalışma zamanını içeren ve yalnızca [DotNet/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) Docker görüntüsünde bulunan paylaşılan çerçevedir.  3,0 SDK, paylaşılan çerçevede kullanılabilir olan kitaplıkların yinelenen kopyalarını dahil etmez, asp.net Core kullanan çerçeveye bağımlı derlemelerin boyutunu azaltır.  Bu, 16 MB 'a kadar olan olası tasarruflar, ancak uygulamayı çalıştırmak için ASP.NET Core çalışma zamanının mevcut olması veya yüklü olmasını gerektirir.

ASP.NET Core paylaşılan çerçevede uygulamanın bir bağımlılığı (doğrudan veya dolaylı) olup olmadığını anlamak için, uygulamanızın derlemesi/yayımlanması sırasında oluşturulan *runtimeconfig. JSON* dosyasını inceleyin. Aşağıdaki JSON dosyası ASP.NET Core paylaşılan çerçeveye bir bağımlılık gösterir:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Uygulamanız Docker kullanıyorsa, ASP.NET Core 3,0 içeren bir temel görüntü kullanın. Örneğin, `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Kaldırılan derlemeler için paket başvuruları Ekle

ASP.NET Core 3,0, daha önce `Microsoft.AspNetCore.App` paket başvurusunun parçası olan bazı derlemeleri kaldırır. Bu derlemeler tarafından sunulan özellikleri kullanmaya devam etmek için, karşılık gelen paketlerin 3,0 sürümlerine başvurun:

* [Microsoft. EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Veritabanı sağlayıcısına özgü pakete başvurma hakkında daha fazla bilgi için bkz. [veritabanı sağlayıcıları](/ef/core/providers/index).

* Kimlik Kullanıcı arabirimi

  [Kimlik Kullanıcı arabirimi](xref:security/authentication/identity) desteği, [Microsoft. Aspnetcore. Identity. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) paketine başvurarak eklenebilir.

* SPA Hizmetleri

  * [Microsoft. AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. AspNetCore. SpaServices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Kimlik doğrulama @no__t-üçüncü taraf kimlik doğrulama akışları için 0 desteği NuGet paketleri olarak sunulmaktadır:

  * Facebook OAuth ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * OpenID Connect taşıyıcı belirteci ([Microsoft. AspNetCore. Authentication. Jwttaşıyıcı](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Microsoft hesabı kimlik doğrulaması ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * OpenID Connect kimlik doğrulaması ([Microsoft. AspNetCore. Authentication. Openıdconnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Twitter OAuth ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * WsFederation kimlik doğrulaması ([Microsoft. AspNetCore. Authentication. WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* @No__t-0 &ndash; için biçimlendirme ve içerik anlaşması desteği [Microsoft. Aspnet. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) NuGet paketi, `ReadAsAsync`, `PostJsonAsync` vb. gibi apı 'lerle `System.Net.HttpClient` ' e faydalı genişletilebilirlik sağlar.

* Razor çalışma zamanı derleme @no__t-Razor görünümlerinin ve sayfalarının çalışma zamanı derlemesi için 0 desteği artık [Microsoft. AspNetCore. Mvc. Razor. RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation)'un bir parçasıdır.

* MVC `Newtonsoft.Json` destek &ndash; `Newtonsoft.Json` ile MVC kullanma desteği artık [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)' ın bir parçasıdır.

### <a name="analyzer-support"></a>Çözümleyici desteği

Daha önce [Microsoft. AspNetCore. Mvc. çözümleyiciler](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) paketinin bir parçası olarak sevk edilen `Microsoft.NET.Sdk.Web` örtük başvuru Çözümleyicileri hedefleyen projeler. Bunları etkinleştirmek için ek başvuru gerekmez.

Uygulamanız daha önce [Microsoft. AspNetCore. Mvc. API. çözümleyiciler](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) paketini kullanarak sevk edilen [API Çözümleyicileri](xref:web-api/advanced/analyzers) kullanıyorsa, .NET Core Web SDK 'sının bir parçası olarak gönderilen çözümleyiciler için proje dosyanızı düzenleyin:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Razor sınıf kitaplığı

MVC için UI bileşenleri sağlayan Razor sınıf kitaplığı projelerinin proje dosyasında `AddRazorSupportForMvc` özelliğini ayarlaması gerekir:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>İşlem içi barındırma modeli

Projeler varsayılan olarak ASP.NET Core 3,0 veya sonraki sürümlerde [işlem içi barındırma modeline](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) göre yapılır. İsteğe bağlı olarak, değeri `InProcess` ise proje dosyasındaki `<AspNetCoreHostingModel>` özelliğini kaldırabilirsiniz.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Yapılandırma

Kestrel yapılandırmasını `ConfigureWebHostDefaults` (*program.cs*) tarafından sağlanmış Web ana bilgisayar oluşturucusuna geçirin:

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Uygulama Konağı `HostBuilder` ile el ile oluşturursa, Web ana bilgisayar Oluşturucu üzerinde `ConfigureWebHostDefaults` ' deki `UseKestrel` ' i çağırın:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Bağlantı ara yazılımı bağlantı bağdaştırıcılarını değiştirir

Bağlantı bağdaştırıcıları (<xref:Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter>) Kestrel adresinden kaldırılmıştır. Bağlantı bağdaştırıcılarını bağlantı ara yazılımı ile değiştirin. Bağlantı ara yazılımı, ASP.NET Core işlem hattındaki HTTP ara hattına benzerdir, ancak alt düzey bağlantılar için. HTTPS ve bağlantı günlüğü:

* Bağlantı bağdaştırıcılarından bağlantı ara yazılıma taşınmıştır.
* Bu uzantı yöntemleri ASP.NET Core önceki sürümlerinde olduğu gibi çalışır. 

Daha fazla bilgi için [Kestrel makalesinin ListenOptions. Protocols bölümünde TlsFilterConnectionHandler örneğine](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols)bakın.

### <a name="transport-abstractions-moved-and-made-public"></a>Taşıma soyutlamaları taşınır ve herkese açık hale getirilir

Kestrel aktarım katmanı `Connections.Abstractions` ' da ortak arabirim olarak kullanıma sunuldu. Bu güncelleştirmelerin bir parçası olarak:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions` ve ilişkili türler kaldırılmıştır.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay> <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> ' den taşıma seçeneklerine taşındı.
* <xref:Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode> <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions> ' den kaldırıldı.

Daha fazla bilgi için aşağıdaki GitHub kaynaklarına bakın:

* [İstemci/sunucu ağı soyutlamaları (ASPNET/AspNetCore #10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [Yeni yatak odası dinleyicisi soyutlama ve yeniden Plat Kestrel for top (ASPNET/AspNetCore #10321) uygulayın](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Kestrel Istek artbilgisi üst bilgileri

ASP.NET Core önceki sürümlerini hedefleyen uygulamalar için:

* Kestrel istek üstbilgileri koleksiyonuna HTTP/1.1 öbekli treyler üstbilgileri ekler.
* İstek gövdesi uca okunduktan sonra Treyi kullanılabilir.

Bu, üst bilgiler ve tanıtımları arasındaki belirsizlik hakkında bazı kaygılara neden olur. bu nedenle, tanıtım bilgileri 3,0 içinde yeni bir koleksiyona (`RequestTrailerExtensions`) taşınmıştır.

HTTP/2 istek fragmanları:

* ASP.NET Core 2,2 ' de kullanılamaz.
* @No__t-0 olarak 3,0 'de kullanılabilir.

Bu treylara erişmek için yeni istek uzantısı yöntemleri vardır. HTTP/1.1 ile olduğu gibi, istek gövdesi sonuna kadar okunduktan sonra treylerle erişilebilir.

3,0 sürümü için aşağıdaki `RequestTrailerExtensions` yöntemleri kullanılabilir:

* `GetDeclaredTrailers` &ndash;, gövdeden sonra beklenme treysini listeleyen `Trailer` üst bilgisini alır.
* `SupportsTrailers` &ndash;, isteğin treyler üstbilgilerini almayı destekleyip desteklemediğini gösterir.
* `CheckTrailersAvailable` &ndash;, isteğin treyleri destekleyip desteklemediğini ve okunmaları için kullanılabilir olup olmadığını denetler. Bu denetim, okunması gereken tanıtımın olduğunu varsaymaz. Bu yöntem tarafından `true` döndürülse bile okumak için hiçbir treyde bulunmayabilir.
* `GetTrailer` &ndash;, yanıttan istenen sondaki üstbilgiyi alır. @No__t-1 ' i çağırmadan önce `SupportsTrailers` ' ı işaretleyin veya istek sondaki üstbilgileri desteklemiyorsa <xref:System.NotSupportedException> olabilir.

Daha fazla bilgi için bkz. [istek fragmanları ayrı bir koleksiyonda (ASPNET/AspNetCore #10410) yerleştirme](https://github.com/aspnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO devre dışı

`AllowSynchronousIO`, `HttpRequest.Body.Read`, `HttpResponse.Body.Write` ve `Stream.Flush` gibi zaman uyumlu GÇ API 'Lerini etkinleştirilir veya devre dışı bırakır. Bu API 'Ler, uygulama kilitlenmelerine neden olan bir iş parçacığı kaynağıdır. 3,0 ' de, `AllowSynchronousIO` varsayılan olarak devre dışıdır. Daha fazla bilgi için [Kestrel makalesindeki zaman uyumlu GÇ bölümüne](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io)bakın.

@No__t-1 seçenekleri ile `AllowSynchronousIO` ' ı etkinleştirmenin yanı sıra, zaman uyumlu GÇ geçici bir risk azaltma olarak istek başına temelinde da geçersiz kılınabilir:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

@No__t-0 uygulamalarıyla veya [Dispose](/dotnet/standard/garbage-collection/implementing-dispose)içinde zaman uyumlu API 'leri çağıran diğer akışlarla ilgili sorun yaşıyorsanız, bunun yerine yeni <xref:System.IO.Stream.DisposeAsync*> API 'sini çağırın.

Daha fazla bilgi için, bkz. [tüm sunucularda [Duyuru] AllowSynchronousIO devre dışı (ASPNET/AspNetCore #7644)](https://github.com/aspnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Microsoft. AspNetCore. Server. Kestrel. https derlemesi kaldırıldı

ASP.NET Core 2,1 ' de, *Microsoft. AspNetCore. Server. Kestrel. https. dll* ' nin içeriği *Microsoft. aspnetcore. Server. Kestrel. Core. dll*' ye taşınmıştır. Bu, `TypeForwardedTo` özniteliklerini kullanan bir kırılmamış güncelleştirmedir. 3,0 için boş *Microsoft. AspNetCore. Server. Kestrel. https. dll* derlemesi ve NuGet paketi kaldırılmıştır.

[Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) ' ye başvuran kitaplıklar ASP.NET Core bağımlılıklarını 2,1 veya üzeri bir sürüme güncelleştirmemelidir.

ASP.NET Core 2,1 veya sonraki bir sürümü hedefleyen uygulamalar ve kitaplıklar, [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) paketine doğrudan başvuruları kaldırmalıdır.

## <a name="jsonnet-support"></a>Json.NET desteği

[ASP.NET Core paylaşılan Framework 'ü geliştirmek](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)için çalışmanın bir parçası olarak, [JSON.net](https://www.newtonsoft.com/json/help/html/Introduction.htm) ASP.NET Core paylaşılan çerçevesinden kaldırılmıştır.

ASP.NET Core için varsayılan değer artık .NET Core 3,0 ' de yeni olan [System. Text. JSON](/dotnet/api/system.text.json?view=netcore-3.0)' dır. Mümkün olduğunda `System.Text.Json` kullanmayı düşünün. Bu yüksek performanstır ve ek bir kitaplık bağımlılığı gerektirmez. Ancak, `System.Text.Json` yeni olduğundan, şu anda uygulamanızın ihtiyaç duyacağı özellikleri eksik olabilir.

Uygulamanız, JsonPatch veya dönüştürücüler gibi @no__t -1 özellikli Özellikler kullanıyorsa veya -3 özgü [türler @no__t biçimindeyse](xref:web-api/advanced/formatting) , uygulamanız `Newtonsoft.Json` tümleştirmesi gerektirebilir.

Bir ASP.NET Core 3,0 SignalR projesinde Json.NET kullanmak için, bu belgede [Newtonsoft. JSON öğesine geçme](#switch-to-newtonsoftjson) bölümüne bakın.

ASP.NET Core 3,0 projesinde Json.NET kullanmak için:

* [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)öğesine bir paket başvurusu ekleyin.
* @No__t-1 ' i çağırmak için @no__t güncelleştirme-0.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`, yeni MVC hizmeti kayıt yöntemleriyle uyumludur:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Json.NET ayarları `AddNewtonsoftJson` ' a yapılan çağrıda ayarlanabilir:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>MVC hizmeti kaydı

ASP.NET Core 3,0, MVC senaryolarını `Startup.ConfigureServices` içinde kaydetmek için yeni seçenekler ekler.

@No__t-0 ' da MVC senaryolarıyla ilgili üç yeni en üst düzey uzantı yöntemi kullanılabilir. Şablonlar `UseMvc` yerine bu yeni yöntemleri kullanır. Ancak, `AddMvc` önceki sürümlerde olduğu gibi davranmaya devam eder.

Aşağıdaki örnek, denetleyiciler ve API ile ilgili özellikler için destek ekler, ancak görünümler veya sayfalar değildir. API şablonu şu kodu kullanır:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Aşağıdaki örnek, denetleyiciler, API ile ilgili özellikler ve görünümler için destek ekler, ancak sayfalar için değildir. Web uygulaması (MVC) şablonu şu kodu kullanır:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Aşağıdaki örnek, Razor Pages ve en düşük denetleyici desteği için destek ekler. Web uygulaması şablonu şu kodu kullanır:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Yeni yöntemler de birleştirilebilir. Aşağıdaki örnek, ASP.NET Core 2,2 ' de `AddMvc` çağırma ile eşdeğerdir:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Yönlendirme başlangıç kodu

Bir uygulama `UseMvc` veya `UseSignalR` ' i çağırırsa, mümkünse uygulamayı [Endpoint Routing](xref:fundamentals/routing) 'e geçirin. MVC 'nin önceki sürümleriyle Endpoint Routing uyumluluğu geliştirmek için ASP.NET Core 2,2 ' de sunulan URL oluşturmayla ilgili bazı değişiklikleri geri çevirdik. 2,2 ' de Endpoint Routing kullanarak sorunlarla karşılaşırsanız, aşağıdaki özel durumlarla ASP.NET Core 3,0 ' de iyileştirmeler beklenir:

* Uygulama `IRouter` ' ı uygular veya `Route` ' den devralırsa, değiştirme olarak [Dynamikro Utevaluestranseski](https://github.com/aspnet/AspNetCore.Docs/issues/12997) kullanın.

* Uygulama, URL 'Leri ayrıştırmak için MVC 'nin içindeki `RouteData.Routers` ' ı doğrudan erişirse, bunu `LinkParser.ParsePathByEndpointName` ' i kullanarak değiştirebilirsiniz. 
 * Yolu bir rota adı ile tanımlayın.
 * @No__t-0 kullanın ve istenen yol adını geçirin.

Endpoint Routing, `IRouter` olarak aynı yol deseninin sözdizimini ve yol deseninin yazma özelliklerini destekler. Uç nokta yönlendirme @no__t destekler-0. Endpoint Routing `[Route]`, `[HttpGet]` ve diğer MVC yönlendirme özniteliklerini destekler.

Çoğu uygulama için yalnızca `Startup` değişiklik gerektirir.

### <a name="migrate-startupconfigure"></a>Geçişi Başlat. yapılandırma

Genel öneri:

* @No__t ekleyin-0.
* Uygulama `UseStaticFiles` ' ı çağırırsa, `UseRouting` ' **den önce** `UseStaticFiles` koyun.
* Uygulama `AuthorizePage` veya `[Authorize]` gibi kimlik doğrulama/yetkilendirme özelliklerini kullanıyorsa, çağrıyı `UseAuthentication` ve `UseAuthorization`: **sonra**, `UseRouting` ve `UseCors`, ancak `UseEndpoints` öncesi:

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* @No__t-0 veya `UseSignalR` ' i `UseEndpoints` ile değiştirin.
* Uygulama, `[EnableCors]` gibi [CORS](xref:security/cors) senaryoları KULLANıYORSA, CORS 'yi kullanan diğer herhangi bir ara yazılım (örneğin, `UseAuthentication`, `UseAuthorization` ve `UseEndpoints` ' dan önce @no__t 3 ' e kadar) için `UseCors` ' ye çağrı koyun.
* @No__t-0 ' i `IWebHostEnvironment` ile değiştirin ve <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> ad alanı için bir `using` açıklaması ekleyin.
* @No__t-0 ' i <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> ad alanı) ile değiştirin.
* @No__t-0 ' i <xref:Microsoft.Extensions.Hosting.Environments> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> ad alanı) ile değiştirin.

Aşağıdaki kod, tipik bir ASP.NET Core 2,2 uygulamasında bir `Startup.Configure` örneğidir:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Önceki `Startup.Configure` kodu güncelleştirildikten sonra:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Çoğu uygulama için, `UseAuthentication`, `UseAuthorization` ve `UseCors` ' ye yapılan çağrılar `UseRouting` ve `UseEndpoints` çağrıları arasında yer almalıdır.

### <a name="health-checks"></a>Sistem durumu denetimleri

Sistem durumu denetimleri, genel ana bilgisayar ile Endpoint Routing kullanır. @No__t-0 ' da, uç nokta URL 'SI veya göreli yol ile Endpoint Builder üzerinde `MapHealthChecks` ' i çağırın:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Durum denetimleri uç noktaları şunları yapabilir:

* İzin verilen bir veya daha fazla Konakları/bağlantı noktasını belirtin.
* Yetkilendirme gerektir.
* CORS gerektir.

Daha fazla bilgi için bkz. <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Güvenlik ara yazılımı Kılavuzu

Yetkilendirme ve CORS desteği, [Ara yazılım](xref:fundamentals/middleware/index) yaklaşımına göre birleştirilmiştir. Bu, bu senaryolarda aynı ara yazılım ve işlevselliğin kullanılmasına izin verir. Bu sürümde güncelleştirilmiş bir yetkilendirme ara yazılımı sunulmaktadır ve CORS ara yazılımı, MVC denetleyicileri tarafından kullanılan öznitelikleri anlayabilmesi için geliştirilmiştir.

#### <a name="cors"></a>CORS

Daha önce CORS yapılandırması zor olabilir. Ara yazılım bazı kullanım durumlarında kullanılmak üzere sağlandı, ancak MVC filtrelerinin diğer kullanım durumlarında ara yazılım **olmadan** kullanılması amaçlandı. ASP.NET Core 3,0 ile, CORS gerektiren tüm uygulamaların, uç nokta yönlendirme ile birlikte CORS ara yazılımını kullanması önerilir. `UseCors` varsayılan ilkeyle birlikte sağlanmış olabilir ve `[EnableCors]` ve `[DisableCors]` öznitelikleri gerektiğinde varsayılan ilkeyi geçersiz kılmak için kullanılabilir.

Aşağıdaki örnekte:

* CORS, `default` adlı ilkeye sahip tüm uç noktalar için etkinleştirilir.
* @No__t-0 sınıfı, CORS 'yi `[DisableCors]` özniteliğiyle devre dışı bırakır.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Authorization

ASP.NET Core önceki sürümlerinde, yetkilendirme desteği `[Authorize]` özniteliği aracılığıyla sağlandı. Yetkilendirme ara yazılımı kullanılamıyor. ASP.NET Core 3,0 ' de, yetkilendirme ara yazılımı gereklidir. ASP.NET Core yetkilendirmesi ara yazılımını (`UseAuthorization`) `UseAuthentication` ' den hemen sonra yerleştirmenizi öneririz. Yetkilendirme ara yazılımı, geçersiz kılınabilen varsayılan ilkeyle de yapılandırılabilir.

ASP.NET Core 3,0 veya sonraki bir sürümde `UseAuthorization` `Startup.Configure` ' de çağrılır ve aşağıdaki `HomeController` oturum açmış bir kullanıcı gerektirir:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Uygulama MVC 'de genel bir filtre olarak `AuthorizeFilter` kullanıyorsa, `AddAuthorization` ' e yapılan çağrıda bir ilke sağlamak için kodu yeniden düzenlemeyi öneririz.

@No__t-0 başlangıçta kimlik doğrulaması gerektirecek şekilde yapılandırılmıştır, bu nedenle ek yapılandırma gerekmez. Aşağıdaki örnekte, tüm isteklerin `DefaultPolicy` temelinde yetkilendirilmiş olması için MVC uç noktaları `RequireAuthorization` olarak işaretlenir. Ancak, `HomeController` `[AllowAnonymous]` nedeniyle kullanıcı uygulamada oturum açmadan erişime izin veriyor:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

İlkeler de özelleştirilebilir. Önceki örneğe derleme sırasında `DefaultPolicy`, kimlik doğrulaması ve belirli bir kapsam gerektirecek şekilde yapılandırılır:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Alternatif olarak, tüm uç noktalar `[Authorize]` veya `RequireAuthorization` olmadan `FallbackPolicy` yapılandırılarak yetkilendirme gerektirecek şekilde yapılandırılabilir. @No__t-0 `DefaultPolicy` ' den farklıdır. @No__t-0 `[Authorize]` veya `RequireAuthorization` tarafından tetiklenir, ancak başka bir ilke ayarlanmamışsa `FallbackPolicy` tetiklenir. `FallbackPolicy` başlangıçta yetkilendirmesiz isteklere izin verecek şekilde yapılandırılır.

Aşağıdaki örnek, önceki `DefaultPolicy` örneği ile aynıdır ancak `[AllowAnonymous]` belirtildiğinde hariç tüm uç noktalarında her zaman kimlik doğrulaması gerektirmek için `FallbackPolicy` kullanır:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Belirli bir yetkilendirme bilgisine sahip olmayan, ara yazılım tarafından yetkilendirme çalışmaktadır. Örneğin, [sistem durumu denetimlerinde](xref:host-and-deploy/health-checks) belirli bir yetkilendirme bilgisi yoktur, ancak sistem durumu denetimleri, ara yazılım tarafından uygulanan yapılandırılabilir bir yetkilendirme ilkesine sahip olabilir.

Ayrıca, her uç nokta yetkilendirme gereksinimlerini özelleştirebilir. Aşağıdaki örnekte, `UseAuthorization` `DefaultPolicy` ile yetkilendirmeyi işler, ancak @no__t 2 durum denetimi uç noktası `admin` Kullanıcı gerektirir:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Koruma bazı senaryolar için uygulanır. Bir yetkilendirme veya CORS ilkesi eksik ara yazılım nedeniyle atlandıysa uç noktalar ara yazılımı bir özel durum oluşturur. Yanlış yapılandırma hakkında ek geribildirim sağlamak için çözümleyici desteği devam ediyor.

### <a name="signalr"></a>SignalR

SignalR hub 'larının eşlemesi artık `UseEndpoints` ' da yer alır.

Her hub `MapHub` ile eşleyin. Önceki sürümlerde olduğu gibi, her hub açık olarak listelenir.

Aşağıdaki örnekte `ChatHub` SignalR hub 'ı için destek eklenmiştir:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

İstemcilerden gelen ileti boyutu sınırlarını denetlemek için yeni bir seçenek vardır. Örneğin, `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

ASP.NET Core 2,2 ' de, `TransportMaxBufferSize` ' ı ayarlayabilir ve en büyük ileti boyutunu etkin bir şekilde denetleyebilirsiniz. ASP.NET Core 3,0 ' de, bu seçenek artık yalnızca geri basınç gözlemlenmeyen en büyük boyutu denetler.

### <a name="mvc-controllers"></a>MVC denetleyicileri

Denetleyicilerin eşlemesi artık `UseEndpoints` ' da yer alır.

Uygulama öznitelik yönlendirme kullanıyorsa, @no__t ekleyin-0. Yönlendirme ASP.NET Core 3,0 veya sonraki sürümlerde birçok çerçeve için destek içerdiğinden, öznitelik yönlendirmeli denetleyiciler eklemek kabul edilir.

Şunları değiştirin:

* `MapRoute` `MapControllerRoute`
* `MapAreaRoute` `MapAreaControllerRoute`

Yönlendirme şimdi yalnızca MVC 'den daha fazlasına destek içerdiğinden, bu yöntemlerin ne yapacaklarına açık bir şekilde sahip olması için terminoloji değişmiştir. @No__t-0 @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4 gibi geleneksel yollar eklendikleri sırayla uygulanır. Önce daha belirli yollar (örneğin, bir alana yönelik yollar) yerleştirin.

Aşağıdaki örnekte:

* `MapControllers` öznitelik yönlendirmeli denetleyiciler için destek ekler.
* `MapAreaControllerRoute` bir alanındaki denetleyiciler için geleneksel bir yol ekler.
* `MapControllerRoute`, denetleyiciler için geleneksel bir yol ekler.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Denetleyici eylem adlarından zaman uyumsuz son ek kaldırma

ASP.NET Core 3,0 ' de, ASP.NET Core MVC `Async` sonekini denetleyici eylem adlarından kaldırır. Hem yönlendirme hem de bağlantı oluşturma, bu yeni varsayılan değerinden etkilenir. Örneğin:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

ASP.NET Core 3,0 öncesi:

* Önceki eyleme *Ürünler/ListAsync* rotası üzerinden erişilebilir.
* @No__t-0 sonekini belirten bağlantı oluşturma gerekiyor. Örneğin:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

ASP.NET Core 3,0:

* Yukarıdaki eyleme, *Ürünler/liste* rotasında erişilebilir.
* Bağlantı oluşturma, `Async` sonekinin belirtilmesini gerektirmez. Örneğin:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Bu değişiklik [[ActionName]](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) özniteliği kullanılarak belirtilen adları etkilemez. Varsayılan davranış `Startup.ConfigureServices` ' da aşağıdaki kodla devre dışı bırakılabilir:

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

### <a name="razor-pages"></a>Razor Pages

Eşleme Razor Pages artık `UseEndpoints` ' da yer alır.

Uygulama Razor Pages kullanıyorsa, @no__t ekleyin-0. Endpoint Routing birçok çerçeve için destek içerdiğinden Razor Pages eklemek artık tercih edilir.

Aşağıdaki `Startup.Configure` yönteminde, `MapRazorPages` Razor Pages için destek ekler:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Endpoint Routing olmadan MVC kullanma

ASP.NET Core 3,0 ' de `UseMvc` veya `UseMvcWithDefaultRoute` aracılığıyla MVC kullanılması `Startup.ConfigureServices` içinde açık bir kabul gerektirir. Bu, MVC 'nin başlatma sırasında yetkilendirme ve CORS ara yazılımını kullanıp kullanamayacağını bilmeleri gerektiğinden gereklidir. Uygulama desteklenmeyen bir yapılandırmayı kullanmayı denerse sizi uyaran bir çözümleyici sağlanır.

Uygulama eski `IRouter` desteği gerektiriyorsa, `Startup.ConfigureServices` ' de aşağıdaki yaklaşımlardan herhangi birini kullanarak `EnableEndpointRouting` ' i devre dışı bırakın:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Sistem durumu denetimleri

Sistem durumu denetimleri, uç nokta yönlendirme özellikli bir *yönlendirici-yazılım* olarak kullanılabilir.

Uç nokta yönlendirme ile sistem durumu denetimlerini kullanmak için `MapHealthChecks` ekleyin. @No__t-0 yöntemi `UseHealthChecks` ' e benzer bağımsız değişkenleri kabul eder. @No__t-1 üzerinden `MapHealthChecks` kullanmanın avantajı, yetkilendirme uygulayabilir ve eşleşen ilke üzerinde daha ayrıntılı denetime sahip olabilir.

Aşağıdaki örnekte, `/healthz` ' de bir sistem durumu denetimi uç noktası için `MapHealthChecks` çağırılır:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder WebHostBuilder 'ın yerini alır

ASP.NET Core 3,0 şablonları [genel konak](xref:fundamentals/host/generic-host)kullanır. Önceki sürümler [Web ana bilgisayarı](xref:fundamentals/host/web-host)kullandı. Aşağıdaki kod, `Program` sınıfı tarafından oluşturulan ASP.NET Core 3,0 şablonunu gösterir:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Aşağıdaki kod, ASP.NET Core 2,2 şablonu tarafından oluşturulan `Program` sınıfını gösterir:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> 3,0 ' de kalır ve önceki kod örneğinde görülen `webBuilder` türüdür. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>, gelecek bir sürümde kullanımdan kaldırılmıştır ve `HostBuilder` ile değiştirilmiştir.

@No__t-0 ' dan `HostBuilder` ' e yapılan en önemli değişiklik, [bağımlılık ekleme (dı)](xref:fundamentals/dependency-injection)içinde. @No__t-0 kullanırken, yalnızca <xref:Microsoft.Extensions.Configuration.IConfiguration> ve <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> @no__t 3 ' e kadar olan oluşturucuya ekleyebilirsiniz. @No__t-0 DI kısıtlamaları:

* Dı kapsayıcısının yalnızca bir kez derlenme özelliğini etkinleştirin.
* Birden çok tekton örneğini çözümlemek gibi ortaya çıkan nesne ömrü sorunlarını önler.

## <a name="addauthorization-moved-to-a-different-assembly"></a>Addaduthorleştirme farklı bir derlemeye taşındı

*Microsoft. AspNetCore. Authorization. dll*' de ASP.NET Core 2,2 ve Lower `AddAuthorization` yöntemleri:

* Yeniden adlandırıldı `AddAuthorizationCore`.
* , *Microsoft. AspNetCore. Authorization. Policy. dll*' ye taşınmıştır.

*Microsoft. aspnetcore. Authorization. dll* ve *Microsoft. Aspnetcore. Authorization. Policy. dll* ' i kullanan uygulamalar etkilenmemektedir.

*Microsoft. AspNetCore. Authorization. Policy. dll* kullanmayan uygulamalar aşağıdakilerden birini yapmanız gerekir:

* @No__t kullanmaya geç-0
* *Microsoft. AspNetCore. Authorization. Policy. dll*öğesine bir başvuru ekleyin.

Daha fazla bilgi için bkz. [`AddAuthorization(o =>` ' deki Son değişiklik, farklı bir derlemede #386 aşırı yükleme yaşar](https://github.com/aspnet/Announcements/issues/386).

## <a name="signalr"></a>SignalR

SignalR JavaScript istemcisi `@aspnet/signalr` ' dan `@microsoft/signalr` ' e değişti. Bu değişikliğe tepki vermek için *Package. JSON* dosyalarındaki başvuruları, `require` deyimlerini ve ECMAScript `import` deyimlerini değiştirin.

### <a name="systemtextjson-is-the-default-protocol"></a>System. Text. JSON varsayılan protokoldür

`System.Text.Json` artık hem istemci hem de sunucu tarafından kullanılan varsayılan Hub protokolüdür.

@No__t-0 ' da, serileştirici seçeneklerini ayarlamak için `AddJsonProtocol` ' i çağırın.

**Server**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**İstemci:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Newtonsoft. JSON öğesine geç

@No__t-1 ' de desteklenmeyen `Newtonsoft.Json` özelliklerini kullanıyorsanız, `Newtonsoft.Json` ' ye dönebilirsiniz:

1. [Microsoft. AspNetCore. SignalR. Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) NuGet paketini yükler.
1. İstemcisinde, `HubConnectionBuilder` örneğine `AddNewtonsoftJsonProtocol` yöntem çağrısını zincirleyebilirsiniz:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. Sunucusunda, `AddNewtonsoftJsonProtocol` yöntem çağrısını `Startup.ConfigureServices` ' deki `AddSignalR` yöntem çağrısına zincirle:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Çalışma zamanı derlemesini kabul et

ASP.NET Core 3,0 ' den önce, görünümlerin çalışma zamanı derlemesi Framework 'ün örtük bir özelliğidir. Çalışma zamanı derlemesi, görünümlerin derleme zamanı derlemesini tamamlar. Bu, Framework 'ün tüm uygulamayı yeniden derlemek zorunda kalmadan Razor görünümlerini ve sayfalarını ( *. cshtml* dosyaları) derleyebilmesine izin verir. Bu özellik, IDE 'de hızlı bir düzenleme yapma ve değişiklikleri görüntülemek için tarayıcıyı yenileme senaryosunu destekler.

ASP.NET Core 3,0 ' de, çalışma zamanı derlemesi bir katılım senaryosudur. Derleme zamanı derlemesi, varsayılan olarak etkinleştirilen görünüm derlemesi için tek mekanizmadır. Çalışma zamanı, *. cshtml* dosyalarında değişiklik algıladığında projeyi yeniden derlemek için Visual Studio Code Içinde Visual Studio veya [DotNet-Watch](xref:tutorials/dotnet-watch) 'u temel alır. Visual Studio 'da, çalıştırılan projedeki *. cs*, *. cshtml*veya *. Razor* dosyalarında yapılan değişiklikler (<kbd>CTRL + F5</kbd>), ancak hata ayıklaması (<kbd>F5</kbd>), projenin yeniden derlenmesi tetiklenemez.

ASP.NET Core 3,0 projenizde çalışma zamanı derlemesini etkinleştirmek için:

1. [Microsoft. AspNetCore. Mvc. Razor. RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation) NuGet paketini yükler.
1. Güncelleştirme `Startup.ConfigureServices` `AddRazorRuntimeCompilation` ' i çağırmak için:

    ASP.NET Core MVC için aşağıdaki kodu kullanın:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    ASP.NET Core Razor Pages için aşağıdaki kodu kullanın:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
@No__t-0 ' daki örnek, geliştirme ortamlarında koşullu çalışma zamanı derlemesini olanaklı bir şekilde etkinleştiren bir örnek gösterir.

Razor dosyası derlemesi hakkında daha fazla bilgi için bkz. <xref:mvc/views/view-compilation>.

## <a name="migrate-libraries-via-multi-targeting"></a>Çoklu hedefleme aracılığıyla kitaplıkları geçirme

Kitaplıklar genellikle ASP.NET Core birden çok sürümünü desteklemelidir. Önceki ASP.NET Core sürümlerine karşı derlenen kitaplıkların çoğu, sorun olmadan çalışmaya devam etmelidir. Aşağıdaki koşullar uygulamanın çapraz derlenmesi için gereklidir:

* Kitaplık, ikili bir [bölme değişikliği](#breaking-api-changes)olan bir özelliği kullanır.
* Kitaplığı ASP.NET Core 3,0 sürümündeki yeni özelliklerden faydalanmak istiyor. 

Örneğin:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

ASP.NET Core 3,0 'e özgü API 'Leri etkinleştirmek için `#ifdefs` kullanın:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>API değişiklikleri kesiliyor

Son değişiklikleri gözden geçir:

* [ASP.NET Core 3,0 sürümündeki son değişikliklerin listesini doldurun](https://github.com/aspnet/Announcements/issues?page=2&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Antiforgery, CORS, Diagnostics, MVC ve yönlendirme IÇINDEKI API değişiklikleri kesiliyor](https://github.com/aspnet/Announcements/issues/387). Bu liste, uyumluluk anahtarlarına yönelik son değişiklikleri içerir.
* .NET Core, ASP.NET Core ve Entity Framework Core arasında 2,2-3,0 ' e kadar olan değişiklikler hakkında bir Özet için bkz. [sürüm 2,2 ' den 3,0 ' e geçiş Için Son değişiklikler](/dotnet/core/compatibility/2.2-3.0).

## <a name="aspnet-core-30-not-currently-available-for-azure-app-service"></a>ASP.NET Core 3,0 şu anda Azure App Service için kullanılamıyor

Bunu yakında kullanıma sunmanızı umuyoruz. Azure App Service ASP.NET Core 3,0 ' [Azure App Service e kadar ASP.NET Core önizleme sürümü dağıtma](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service)bölümündeki yönergeleri izleyin.

## <a name="mysqldataentityframeworkcore-not-currently-supported-on-aspnet-core-30"></a>MySql. Data. EntityFrameworkCore Şu anda ASP.NET Core 3,0 üzerinde desteklenmiyor

Daha fazla bilgi için [bu GitHub sorunu](https://github.com/aspnet/EntityFrameworkCore/issues/17788).
