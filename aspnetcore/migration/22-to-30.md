---
title: ASP.NET Core 2.2 ile 3.0 arası geçiş
author: rick-anderson
description: Core 3.0'ı ASP.NET bir ASP.NET Core 2.2 projesini nasıl geçirteceklerini öğrenin.
ms.author: riande
ms.custom: mvc
ms.date: 01/21/2020
no-loc:
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 46223011e82c7115147f59ee03e20d8033103b98
ms.sourcegitcommit: f0aeeab6ab6e09db713bb9b7862c45f4d447771b
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/08/2020
ms.locfileid: "80977242"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>ASP.NET Core 2.2 ile 3.0 arası geçiş

Scott [Addie](https://github.com/scottaddie) ve [Rick Anderson](https://twitter.com/RickAndMSFT) tarafından

Bu makalede, varolan bir ASP.NET Core 2.2 projesinin Core 3.0'ASP.NET nasıl güncelleştirilen açıklanmaktadır.

## <a name="prerequisites"></a>Ön koşullar

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mac"></a>[Mac için Visual Studio](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>global.json'da .NET Core SDK sürümünü güncelleyin

Çözümünüz belirli bir .NET Core SDK sürümünü hedeflemek için [global.json](/dotnet/core/tools/global-json) dosyasına güveniyorsa, özelliğini `version` makinenizde yüklü olan 3.0 sürümüne güncelleyin:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Proje dosyasını güncelleştirme

### <a name="update-the-target-framework"></a>Hedef Çerçeveyi Güncelleştir

Core 3.0 ASP.NET ve daha sonra yalnızca .NET Core'da çalışır. Hedef [Çerçeve Takma Kabını (TFM)](/dotnet/standard/frameworks) şu şekilde `netcoreapp3.0`ayarlayın:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Eski paket başvurularını kaldırma

Core 3.0 için çok sayıda NuGet paketi ASP.NET için üretilmesin. Bu tür paket başvuruları proje dosyanızdan kaldırılmalıdır. ASP.NET Core 2.2 web uygulaması için aşağıdaki proje dosyasını göz önünde bulundurun:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

Core 3.0 ASP.NET için güncelleştirilmiş proje dosyası:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

Güncelleştirilmiş ASP.NET Core 3.0 proje dosyası:

* `<PropertyGroup>`Içinde:
  * TFM'yi günceller`netcoreapp3.0`
  * Öğeyi `<AspNetCoreHostingModel>` kaldırır. Daha fazla bilgi için bu belgedeki [süreç içi barındırma modeline](#in-process-hosting-model) bakın.

* `<ItemGroup>`Içinde:
  * `Microsoft.AspNetCore.App`kaldırılır. Daha fazla bilgi için bu belgedeki [Çerçeve başvurusuna](#framework-reference) bakın.
  * `Microsoft.AspNetCore.Razor.Design`kaldırılır ve artık üretilmemektedir paketlerin aşağıdaki listesinde.

Artık üretilmeyen paketlerin tam listesini görmek için aşağıdaki genişletme listesini seçin:

<details>
    <summary>Artık üretilmeyen paketlerin listesini genişletmek için tıklayın</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft.AspNetCore.SignalR</li>
        <li>Microsoft.AspNetCore. SignalR. Çekirdek</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net.Http.Headers </li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Son kesme değişikliklerini gözden geçirme

[Son kesme değişikliklerini gözden geçirme](#break)

### <a name="framework-reference"></a>Çerçeve başvurusu

yukarıda listelenen paketlerden biri aracılığıyla kullanılabilen ASP.NET Core'un `Microsoft.AspNetCore.App` özellikleri paylaşılan çerçevenin bir parçası olarak mevcuttur. *Paylaşılan çerçeve,* makineye yüklenen *.dll* ve çalışma zamanı bileşeni ve hedefleme paketi içeren derlemeler kümesidir. Daha fazla bilgi için [paylaşılan çerçeveye](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/)bakın.

* SDK'yı `Microsoft.NET.Sdk.Web` hedefleyen projeler çerçeveye dolaylı olarak başvurur. `Microsoft.AspNetCore.App`

  Bu projeler için ek başvuru gerekmez:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* Hedef `Microsoft.NET.Sdk` veya `Microsoft.NET.Sdk.Razor` SDK projeleri, açık `FrameworkReference` `Microsoft.AspNetCore.App`eklemelisiniz:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Docker kullanarak çerçeveye bağımlı yapılar

Core [paylaşılan çerçevesi](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) ASP.NETne bağlı bir paket kullanan konsol uygulamalarının çerçeveye bağımlı yapıları aşağıdaki çalışma zamanı hatasını verebilir:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App`core çalışma süresini ASP.NET içeren paylaşılan çerçevedir ve yalnızca [dotnet/core/aspnet](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) Docker görüntüsünde bulunur. 3.0 SDK, paylaşılan çerçevede bulunan kitaplıkların yinelenen kopyalarını dahil etmeyerek ASP.NET Core kullanarak çerçeveye bağımlı yapıların boyutunu azaltır. Bu 18 MB'a kadar potansiyel bir tasarruftur, ancak uygulamayı çalıştırmak için ASP.NET Core çalışma süresinin mevcut / yüklü olmasını gerektirir.

Uygulamanın ASP.NET Core paylaşılan çerçevesi üzerinde bir bağımlılığı (doğrudan veya dolaylı) olup olmadığını belirlemek için, uygulamanızın oluşturulması/yayınlanması sırasında oluşturulan *runtimeconfig.json* dosyasını inceleyin. Aşağıdaki JSON dosyası, ASP.NET Core paylaşılan çerçevesine bir bağımlılık gösterir:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Uygulamanız Docker kullanıyorsa, Core 3.0 ASP.NET içeren bir temel resim kullanın. Örneğin, `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Kaldırılan derlemeler için paket başvuruları ekleme

ASP.NET Core 3.0, daha önce paket referansının `Microsoft.AspNetCore.App` bir parçası olan bazı derlemeleri kaldırır. Hangi derlemelerin kaldırıldığını görselleştirmek için paylaşılan iki çerçeve klasörünü karşılaştırın. Örneğin, 2.2.7 ve 3.0.0 sürümlerinin karşılaştırılması:

![paylaşılan çerçeve derlemeleri karşılaştırması](22-to-30/_static/assembly-diff.png)

Kaldırılan derlemeler tarafından sağlanan özellikleri kullanmaya devam etmek için, ilgili paketlerin 3.0 sürümlerine başvurun:

* **Bireysel Kullanıcı Hesapları** içeren şablon tarafından oluşturulan bir web uygulaması, aşağıdaki paketleri eklemeyi gerektirir:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft.EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Veritabanı sağlayıcısına özgü pakete başvurma hakkında daha fazla bilgi için [Veritabanı Sağlayıcıları'na](/ef/core/providers/index)bakın.

* Kimlik UI

  Kimlik [UI](xref:security/authentication/identity) desteği [Microsoft.AspNetCore.Identity.UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) paketine başvurarak eklenebilir.

* SPA Hizmetleri

  * [Microsoft.AspNetCore.SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft.AspNetCore.SpaServices.Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Üçüncü &ndash; taraf kimlik doğrulama akışları için kimlik doğrulama desteği NuGet paketleri olarak kullanılabilir:

  * Facebook OAuth ([Microsoft.AspNetCore.Authentication.Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft.AspNetCore.Authentication.Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Microsoft Hesabı kimlik doğrulaması ([Microsoft.AspNetCore.Authentication.MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * OpenID Connect kimlik doğrulaması ([Microsoft.AspNetCore.Authentication.OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * OpenID Connect taşıyıcı belirteci ([Microsoft.AspNetCore.Authentication.JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Twitter OAuth ([Microsoft.AspNetCore.Authentication.Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * WsFederation kimlik doğrulama ([Microsoft.AspNetCore.Authentication.WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* [Microsoft.AspNet.WebApi.Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) NuGet paketi `System.Net.HttpClient` için `ReadAsAsync` `System.Net.HttpClient` &ndash; biçimlendirme ve içerik anlaşma desteği, API'ler `PostJsonAsync`gibi ve .

* Razor görünümleri &ndash; ve sayfaların çalışma zamanı derlemesi için Razor runtime derleme Desteği artık [Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation'ın](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation)bir parçasıdır.

* MVC `Newtonsoft.Json` (Json.NET) &ndash; ile `Newtonsoft.Json` MVC kullanmak için destek Desteği şimdi [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)bir parçasıdır.

## <a name="startup-changes"></a>Başlangıç değişiklikleri

Aşağıdaki resim, ASP.NET Core 2.2 Razor Pages Web uygulamasında silinen ve değiştirilen satırları gösterir:

![ASP.NET Core 2.2 Razor Web uygulamasında silinen ve değiştirilen satırlar](22-to-30/_static/startup2.2.png)

Önceki resimde, silinen kod kırmızı renkle gösterilir. Silinen kod, dosyaları karşılaştırmadan önce silinen çerez seçenekleri kodunu göstermez.

Aşağıdaki resim, ASP.NET core 3.0 Razor Pages Web uygulamasında eklenen ve değiştirilen satırları gösterir:

![ASP.NET Core 3.0 Razor Web uygulamasında eklenen ve değiştirilen satırlar](22-to-30/_static/startup3.0.png)

Önceki resimde, eklenen kod yeşil renkte gösterilir. Aşağıdaki değişiklikler hakkında bilgi için:

* `services.AddMvc`için `services.AddRazorPages`, bu belgede [MVC hizmet kaydı](#mvc-service-registration) bakın.
* `CompatibilityVersion`, <xref:mvc/compatibility-version>bkz.
* `IHostingEnvironment`için `IWebHostEnvironment`, [bu GitHub duyuru](https://github.com/dotnet/AspNetCore/issues/7749)bakın .
* `app.UseAuthorization`sipariş yetkilendirme ara ware'inin eklenmesi gerektiğini göstermek için şablonlara eklendi. Uygulama yetkilendirme kullanmıyorsa, `app.UseAuthorization`'ye yapılan aramayı güvenli bir şekilde kaldırabilirsiniz.
* `app.UseEndpoints`, bu belgede [Razor Pages](#razor-pages) veya [Migrate Startup.Configure'ye](#migrate-startupconfigure) bakın.

### <a name="analyzer-support"></a>Analyzer desteği

Daha önce `Microsoft.NET.Sdk.Web` [Microsoft.AspNetCore.Mvc.Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) paketinin bir parçası olarak gönderilen çözümleyicileri dolaylı olarak hedefleyen projeler. Bunları etkinleştirmek için ek başvuru gerekmez.

Uygulamanız daha önce [Microsoft.AspNetCore.Mvc.Api.Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) paketini kullanarak gönderilen [API çözümleyicilerini](xref:web-api/advanced/analyzers) kullanıyorsa, .NET Core Web SDK'nın bir parçası olarak gönderilen çözümleyicilere başvurmak için proje dosyanızı edin:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Razor Sınıf Kütüphanesi

MVC için UI bileşenleri sağlayan Razor Class `AddRazorSupportForMvc` Kitaplığı projeleri proje dosyasındaki özelliği ayarlamalıdır:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Süreç içi barındırma modeli

Core 3.0 veya daha sonra [ASP.NET'daki süreç içi barındırma modeline](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) varsayılan projeler. `<AspNetCoreHostingModel>` Değeri `InProcess`.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Yapılandırma

Kerkenez yapılandırmasını ( `ConfigureWebHostDefaults` *Program.cs:*

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Uygulama, ana bilgisayarı el ile `HostBuilder`oluşturursa, web `ConfigureWebHostDefaults`ana bilgisayar oluşturucuyu şu şekilde arayın: `UseKestrel`

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Bağlantı Middleware Bağlantı Bağdaştırıcıları değiştirir

Bağlantı Bağdaştırıcıları (`Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter`) Kerkenez'den kaldırıldı. Bağlantı Bağdaştırıcılarını Bağlantı Middleware ile değiştirin. Bağlantı Middleware ASP.NET Core boru hattı nda HTTP Middleware benzer ama alt düzey bağlantılar için. HTTPS ve bağlantı günlüğü:

* Bağlantı Bağdaştırıcılarından Bağlantı Middleware'e taşınmıştır.
* Bu uzantı yöntemleri ASP.NET Core'un önceki sürümlerinde olduğu gibi çalışır. 

Daha fazla bilgi için, [Kerkenez makalesinin ListenOptions.Protocols bölümündeki TlsFilterConnectionHandler örneğine](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols)bakın.

### <a name="transport-abstractions-moved-and-made-public"></a>Taşıma soyutlamaları taşındı ve kamuya duyuruldu

Kerkenez aktarım katmanı, 'de `Connections.Abstractions`genel bir arayüz olarak ortaya çıkmıştır. Bu güncelleştirmelerin bir parçası olarak:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`ve ilişkili türleri kaldırıldı.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>taşıma <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> seçeneklerine taşındı.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode`<xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>kaldırıldı.

Daha fazla bilgi için aşağıdaki GitHub kaynaklarına bakın:

* [İstemci/sunucu ağ soyutlamaları (dotnet/AspNetCore #10308)](https://github.com/dotnet/AspNetCore/issues/10308)
* [Yeni ana kaya dinleyici soyutlama ve üstüne re-plat Kestrel uygulayın (dotnet / AspNetCore #10321)](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Kerkenez İstek römork başlıkları

ASP.NET Core'un önceki sürümlerini hedefleyen uygulamalar için:

* Kestrel, istek üstbilgikoleksiyonuna HTTP/1.1 parçalanmış römork başlıklarını ekler.
* Römorklar istek gövdesi sonuna kadar okunduktan sonra kullanılabilir.

Bu başlıklar ve römorklar arasında belirsizlik hakkında bazı endişelere neden olur, bu`RequestTrailerExtensions`yüzden römorklar yeni bir koleksiyona taşınmıştır ( ) 3.0.

HTTP/2 istek römorkları şunlardır:

* ASP.NET Core 2.2'de kullanılamaz.
* 3.0 olarak `RequestTrailerExtensions`mevcuttur.

Bu römorklara erişmek için yeni istek uzatma yöntemleri mevcuttur. HTTP/1.1'de olduğu gibi, istek gövdesi sonuna kadar okunduktan sonra römorklar mevcuttur.

3.0 sürümü için aşağıdaki `RequestTrailerExtensions` yöntemler mevcuttur:

* `GetDeclaredTrailers`&ndash; Gövdeden `Trailer` sonra hangi römorkların beklenebilir listeler istek üstbilgisini alır.
* `SupportsTrailers`&ndash; İsteğin römork üstbilgisini desteklemesini gösterir.
* `CheckTrailersAvailable`&ndash; İsteğin römorkları destekleyip desteklemeyeceğini ve okunabilmek için uygun olup olmadığını denetler. Bu çek, okunacak römorklar olduğunu varsaymıyor. Bu yöntemle döndürülse `true` bile okunacak römork olmayabilir.
* `GetTrailer`&ndash; İstenilen sondaki üstbilgiyanıttan alır. Aramadan `SupportsTrailers` `GetTrailer`önce kontrol edin veya istek sondaki üstbilgidesteği yoksa oluşabilir. <xref:System.NotSupportedException>

Daha fazla bilgi için, [ayrı bir koleksiyonda (dotnet/AspNetCore #10410) istek römorkları koyun](https://github.com/dotnet/AspNetCore/pull/10410)bakın.

### <a name="allowsynchronousio-disabled"></a>SynchronousIO devre dışı izin

`AllowSynchronousIO`gibi eşzamanlı G/Ç API'lerini `HttpRequest.Body.Read` `HttpResponse.Body.Write`etkinleştirir veya devre `Stream.Flush`dışı kılabilir. Bu API'ler uygulama çökmelerine yol açan bir iş parçacığı açlığı kaynağıdır. 3.0'da, `AllowSynchronousIO` varsayılan olarak devre dışı bırakılır. Daha fazla bilgi için [Kerkenez makalesindeki Senkron G/Ç bölümüne](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io)bakın.

Senkron G/Ç gerekiyorsa, kullanılan sunucudaki `AllowSynchronousIO` seçeneği yapılandırarak etkinleştirilebilir (örneğin, `ConfigureKestrel`Kestrel kullanıyorsanız, arama yaparken). Sunucuların (Kestrel, HttpSys, TestServer, vb.) `AllowSynchronousIO` diğer sunucuları etkilemeyecek kendi seçenekleri olduğunu unutmayın. Senkron G/Ç `IHttpBodyControlFeature.AllowSynchronousIO` seçeneği kullanılarak istek başına tüm sunucular için etkinleştirilebilir:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

[Elden Çıkar'da](/dotnet/standard/garbage-collection/implementing-dispose)eşzamanlı API'leri arayan uygulamalar veya diğer akışlarla <xref:System.IO.Stream.DisposeAsync*> ilgili <xref:System.IO.TextWriter> sorun yaşıyorsanız, bunun yerine yeni API'yi arayın.

Daha fazla bilgi için [bkz: [Duyuru] AllowSynchronousIO tüm sunucularda devre dışı (dotnet/AspNetCore #7644)](https://github.com/dotnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Microsoft.AspNetCore.Server.Kestrel.Https derlemesi kaldırıldı

Core 2.1ASP.NET, *Microsoft.AspNetCore.Server.Kestrel.Https.dll* içeriği *Microsoft.AspNetCore.Server.Kestrel.Core.dll*taşındı . Bu öznitelikleri kullanarak `TypeForwardedTo` kırılmayan bir güncelleştirme oldu. 3.0 için boş *Microsoft.AspNetCore.Server.Kestrel.Https.dll* derlemesi ve NuGet paketi kaldırıldı.

[Microsoft.AspNetCore.Server.Kestrel.Https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) adresine başvuran kitaplıklar, Temel bağımlılıkları 2.1 veya daha sonra ASP.NET güncelleştirmelidir.

Core 2.1 veya daha ASP.NET hedefleyen uygulamalar ve kitaplıklar [Microsoft.AspNetCore.Server.Kestrel.Https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) paketine yapılan doğrudan başvuruları kaldırmalıdır.

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>Newtonsoft.Json (Json.NET) desteği

ASP.NET Core paylaşılan [çerçevegeliştirmek](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)için çalışmanın bir parçası olarak, [Newtonsoft.Json (Json.NET)](https://www.newtonsoft.com/json/help/html/Introduction.htm) ASP.NET Core paylaşılan çerçeve kaldırıldı.

ASP.NET Core için varsayılan JSON serializer şimdi <xref:System.Text.Json>, hangi .NET Core 3.0 yenidir. Mümkün `System.Text.Json` olduğunda kullanmayı düşünün. Yüksek performanslıdır ve ek bir kitaplık bağımlılığı gerektirmez. Ancak, `System.Text.Json` yeni olduğundan, şu anda uygulamanızın ihtiyaç duyduğu özellikler eksik olabilir. Daha fazla bilgi için, [Newtonsoft.Json'dan System.Text.Json'a nasıl göç edilene](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)bakın.

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-opno-locsignalr-project"></a>Newtonsoft.Json'ı ASP.NET Core 3.0 SignalR projesinde kullanın

* [Microsoft.AspNetCore yükleyin. .SignalR Protokoller.NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) NuGet paketi.

* İstemci üzerinde, `AddNewtonsoftJsonProtocol` `HubConnectionBuilder` örnek için bir yöntem çağrısı zincir:

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chatHub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* Sunucuda, zincir `AddNewtonsoftJsonProtocol` bir yöntem `AddSignalR` arama için `Startup.ConfigureServices`çağrı:

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>Newtonsoft.Json'ı ASP.NET Core 3.0 MVC projesinde kullanın

* [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) paketini yükleyin.

* Aramak `Startup.ConfigureServices` `AddNewtonsoftJson`için güncelleştirin.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`yeni MVC hizmet kayıt yöntemleri ile uyumludur:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  `Newtonsoft.Json`ayarlar için çağrı `AddNewtonsoftJson`ayarlanabilir:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

**Not:** `AddNewtonsoftJson` Yöntem kullanılamıyorsa, [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) paketini yüklediğinizden emin olun. Yaygın bir hata [Yerine Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) paketi [Newtonsoft.Json](https://www.nuget.org/packages/Newtonsoft.Json/) paketi yüklemektir.

## <a name="mvc-service-registration"></a>MVC hizmet kaydı

ASP.NET Core 3.0 içinde `Startup.ConfigureServices`MVC senaryoları kayıt için yeni seçenekler ekler.

Üzerinde `IServiceCollection` MVC senaryoları ile ilgili üç yeni üst düzey uzatma yöntemleri mevcuttur. Şablonlar bu yeni yöntemleri `AddMvc`' ler yerine kullanır. Ancak, `AddMvc` önceki sürümlerde olduğu gibi olmaya devam eder.

Aşağıdaki örnek, denetleyiciler ve API ile ilgili özellikler için destek ekler, ancak görünümler veya sayfalar için destek eklemez. API şablonu bu kodu kullanır:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Aşağıdaki örnek, sayfalar için değil, denetleyiciler, API ile ilgili özellikler ve görünümler için destek ekler. Web Uygulaması (MVC) şablonu bu kodu kullanır:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Aşağıdaki örnek, Razor Pages ve minimal denetleyici desteği için destek ekler. Web Uygulaması şablonu bu kodu kullanır:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Yeni yöntemler de birleştirilebilir. Aşağıdaki örnek, Core `AddMvc` 2.2'ASP.NET aramaya eşdeğerdir:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Yönlendirme başlangıç kodu

Bir uygulama `UseMvc` ararsa veya `UseSignalR`mümkünse [uygulamayı Endpoint Yönlendirme'ye](xref:fundamentals/routing) geçirin. MVC'nin önceki sürümleriyle Endpoint Yönlendirme uyumluluğunu artırmak için, ASP.NET Core 2.2'de tanıtılan URL üretimindeki bazı değişiklikleri geri aldık. 2,2'de Endpoint Yönlendirme'yi kullanarak sorun yaşadıysanız, aşağıdaki istisnalar dışında ASP.NET Core 3.0'da iyileştirmeler bekliyoruz:

* Uygulama uygular `IRouter` veya `Route`devralır, yerine [DynamicRouteValuesTransformer](https://github.com/dotnet/AspNetCore.Docs/issues/12997) kullanın.
* Uygulama URL'leri `RouteData.Routers` ayrıştırmak için Doğrudan MVC içinde erişirse, [linkparser.ParsePathByEndpointName](xref:Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions.ParsePathByEndpointName*)kullanımı ile değiştirebilirsiniz. 
  * Rotayı bir rota adı ile tanımlayın.
  * İstediğiniz rota adında kullanın `LinkParser.ParsePathByEndpointName` ve geçirin.

Endpoint Yönlendirme aynı rota deseni sözdizimi ve rota `IRouter`desen yazma özelliklerini destekler. Endpoint Yönlendirme destekler. `IRouteConstraint` Uç nokta yönlendirme, `[Route]` `[HttpGet]`ve diğer MVC yönlendirme öznitelikleridestekler.

Çoğu uygulama için `Startup` yalnızca değişiklik gerektirir.

### <a name="migrate-startupconfigure"></a>Geçiş Başlangıç.Configure

Genel tavsiye:

* Ekle `UseRouting`.
* `UseStaticFiles`Uygulama ararsa `UseStaticFiles` , **önce** `UseRouting`yer .
* Uygulama kimlik `AuthorizePage` doğrulama/yetkilendirme özellikleri kullanıyorsa veya `[Authorize]`, `UseAuthentication` `UseAuthorization`aramayı yerleştirin `UseRouting` `UseCors`ve : `UseEndpoints` **sonra**, ve , ama önce :

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Değiştir `UseMvc` `UseSignalR` veya `UseEndpoints`değiştirin.
* Uygulama [CORS](xref:security/cors) `[EnableCors]`senaryoları kullanıyorsa, örneğin, `UseCors` aramayı CORS kullanan diğer ara yazılımlardan `UseCors` önce `UseAuthentication` `UseAuthorization`yerleştirin `UseEndpoints`(örneğin, önce , ve ).
* Ad `IHostingEnvironment` `IWebHostEnvironment` alanı ile `using` değiştirin <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> ve bir deyim ekleyin.
* (ad <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> alanı) ile değiştirin. `IApplicationLifetime`
* (ad <xref:Microsoft.Extensions.Hosting.Environments> <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> alanı) ile değiştirin. `EnvironmentName`

Aşağıdaki kod, tipik `Startup.Configure` bir ASP.NET Core 2.2 uygulamasındabir örnektir:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Önceki `Startup.Configure` kodu güncelledikten sonra:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Çoğu `UseAuthentication`uygulama için , `UseAuthorization`ve `UseCors` aramalar arasında görünmesi `UseRouting` `UseEndpoints` ve etkili olması gerekir.

### <a name="health-checks"></a>Sistem durumu denetimleri

Sistem Durumu Denetimleri, Genel Ana Bilgisayar ile uç nokta yönlendirmeyi kullanır. In, `Startup.Configure` `MapHealthChecks` bitiş noktası URL'si veya göreli yolu olan bitiş noktası oluşturucuyu arayın:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Sistem Durumu Denetimleri bitiş noktaları şunları yapabilir:

* İzin verilen bir veya daha fazla ana bilgisayar/bağlantı noktası belirtin.
* Yetkilendirme gerektirir.
* CORS gerektirir.

Daha fazla bilgi için bkz. <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Güvenlik ara yazılım kılavuzu

Yetkilendirme desteği ve CORS [ara yazılım](xref:fundamentals/middleware/index) yaklaşımı etrafında birleştirilir. Bu, bu senaryolar arasında aynı ara yazılım ve işlevselliğin kullanılmasına olanak sağlar. Bu sürümde güncelleştirilmiş bir yetkilendirme ara ware'i sağlanır ve CORS Middleware, MVC denetleyicileri tarafından kullanılan öznitelikleri anlayabilecek şekilde geliştirilmiştir.

#### <a name="cors"></a>CORS

Daha önce, CORS yapılandırmak zor olabilir. Middleware bazı kullanım durumlarda kullanılmak üzere sağlanmıştır, ancak MVC filtreleri diğer kullanım durumlarda middleware **olmadan** kullanılmak üzere tasarlanmıştır. Core 3.0 ASP.NET ile, CORS gerektiren tüm uygulamaların ENDPoint Yönlendirme ile birlikte CORS Middleware'i kullanmasını öneririz. `UseCors`varsayılan bir ilke ile `[EnableCors]` sağlanabilir ve `[DisableCors]` öznitelikler gerektiğinde varsayılan ilkeyi geçersiz kılmak için kullanılabilir.

Aşağıdaki örnekte:

* `default` CORS, adlandırılmış ilke ile tüm uç noktalar için etkinleştirilir.
* Sınıf `MyController` öznitelik ile `[DisableCors]` CORS devre dışı kılabilir.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Yetkilendirme

ASP.NET Core'un önceki sürümlerinde, yetkilendirme `[Authorize]` desteği öznitelik üzerinden sağlanmıştır. Yetkilendirme ara ware kullanılamadı. ASP.NET Core 3.0'da yetkilendirme aracı gereklidir. Biz hemen sonra`UseAuthorization` `UseAuthentication`ASP.NET Çekirdek Yetkilendirme Middleware ( ) yerleştirmenizi öneririz. Yetkilendirme Middleware da geçersiz kılınabilir varsayılan bir ilke ile yapılandırılabilir.

ASP.NET Core 3.0 veya `UseAuthorization` daha `Startup.Configure`sonra, çağrılır ve aşağıdaki `HomeController` kullanıcı imzalı gerektirir:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Uç nokta yönlendirmesini kullanırken, yapılandırmaya `<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>` karşı ve bunun yerine Yetkilendirme ara yazılımına güvenmenizi öneririz.  Uygulama MVC'de genel bir filtre `AuthorizeFilter` olarak kullanıyorsa, `AddAuthorization`aramada bir ilke sağlamak için kodu yeniden düzenlemenizi öneririz.

Başlangıçta `DefaultPolicy` kimlik doğrulaması gerektirecek şekilde yapılandırılır, bu nedenle ek yapılandırma gerekmez. Aşağıdaki örnekte, MVC uç noktaları, `RequireAuthorization` tüm isteklerin `DefaultPolicy`. Ancak, `HomeController` kullanıcı nedeniyle uygulamaya oturum açmadan `[AllowAnonymous]`erişim sağlar:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>Belirli uç noktalar için yetkilendirme

Yetkilendirme, belirli uç nokta sınıfları için de yapılandırılabilir. Aşağıdaki kod, yetkilendirme gerektiren belirli bir ilke ile `AuthorizeFilter` bir uygulamaya bir küresel yapılandırılan bir MVC uygulaması dönüştürme bir örnektir:

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

İlkeler de özelleştirilebilir. Kimlik `DefaultPolicy` doğrulaması gerektirecek şekilde yapılandırılır:

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

Alternatif olarak, tüm uç noktalar `[Authorize]` `RequireAuthorization` bir `FallbackPolicy`. Farklı `FallbackPolicy` `DefaultPolicy`olan. Başka `DefaultPolicy` bir ilke ayarlanamadığında tetiklenir `[Authorize]` veya `RequireAuthorization`, `FallbackPolicy` tarafından tetiklenir. `FallbackPolicy`başlangıçta yetkilendirme olmadan isteklerine izin verecek şekilde yapılandırılır.

Aşağıdaki örnek, önceki `DefaultPolicy` örnekle aynıdır, ancak `FallbackPolicy` belirtilen durumlar `[AllowAnonymous]` dışında tüm uç noktalarda her zaman kimlik doğrulaması gerektirmeyi kullanır:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

Ara yazılım yetkilendirmesi, belirli bir yetkilendirme bilgisine sahip olmayan bir çerçeve olmadan çalışır. Örneğin, [sistem durumu denetimlerinin](xref:host-and-deploy/health-checks) belirli bir yetkilendirme bilgisi yoktur, ancak sistem durumu denetimleri ara yazılım tarafından uygulanan bir yapılandırılabilir yetkilendirme ilkesine sahip olabilir.

Ayrıca, her bitiş noktası yetkilendirme gereksinimlerini özelleştirebilir. Aşağıdaki örnekte, `UseAuthorization` yetkilendirmeyi `DefaultPolicy`, ancak `/healthz` sistem durumu denetimi `admin` bitiş noktası ile işler, bir kullanıcı gerektirir:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Koruma, bazı senaryolar için uygulanır. Bitiş Noktaları Middleware bir yetkilendirme veya CORS ilkesi eksik ara nedeniyle atlanırsa bir özel durum atar. Yanlış yapılandırma hakkında ek geribildirim sağlamak için çözümleyici desteği devam etmektedir.

#### <a name="custom-authorization-handlers"></a>Özel yetkilendirme işleyicileri

Uygulama özel [yetkilendirme işleyicileri kullanıyorsa,](xref:security/authorization/policies#authorization-handlers)uç nokta yönlendirme, Işleyicilere MVC'den farklı bir kaynak türü geçer. Yetkilendirme işleyicisi bağlam kaynağının türde <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> olmasını bekleyen işleyicilerin [(MVC filtreleri tarafından sağlanan](xref:security/authorization/policies#accessing-mvc-request-context-in-handlers)kaynak <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> türü) türündeki kaynakları işlemek için güncelleştirilmeleri gerekir (bitiş noktası yönlendirmesi ile yetkilendirme işleyicilerine verilen kaynak türü).

MVC hala `AuthorizationFilterContext` kaynakları kullanır, bu nedenle uygulama son nokta yönlendirme yetkilendirmesi ile birlikte MVC yetkilendirme filtreleri kullanıyorsa, her iki kaynak türünü işlemek gerekebilir.

### SignalR

Hub'ların SignalR haritalama şimdi `UseEndpoints`içinde yer alır.

Her hub'ı `MapHub`. Önceki sürümlerde olduğu gibi, her hub açıkça listelenir.

Aşağıdaki örnekte, `ChatHub` SignalR hub desteği eklenir:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

İstemcilerden gelen ileti boyutu sınırlarını denetlemek için yeni bir seçenek vardır. Örneğin, içinde: `Startup.ConfigureServices`

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

Core 2.2ASP.NET, maksimum ileti `TransportMaxBufferSize` boyutunu etkin bir şekilde ayarlayabilirsiniz. Core 3.0ASP.NET, bu seçenek artık yalnızca geri basınç gözlemlenmeden önce maksimum boyutu kontrol eder.

### <a name="mvc-controllers"></a>MVC denetleyicileri

Denetleyicilerin haritalama şimdi `UseEndpoints`içinde yer alır.

Uygulama `MapControllers` öznitelik yönlendirme kullanıyorsa ekleyin. Yönlendirme, Core 3.0 veya daha sonra ASP.NET birçok çerçeve için destek içerdiğinden, öznitelik yönlendirilmiş denetleyiciler eklemek kabul edilir.

Aşağıdakileri değiştirin:

* `MapRoute`Ile`MapControllerRoute`
* `MapAreaRoute`Ile`MapAreaControllerRoute`

Yönlendirme artık sadece MVC daha fazla destek içerdiğinden, terminoloji bu yöntemleri açıkça ne yaptıklarını devlet yapmak için değişti. `MapControllerRoute` / Gibi `MapAreaControllerRoute` / yollar eklendikleri sırayla `MapDefaultControllerRoute` uygulanır. Önce daha özel rotalar (bir alan için rotalar gibi) yerleştirin.

Aşağıdaki örnekte:

* `MapControllers`öznitelik yönlendirilmiş denetleyicileri için destek ekler.
* `MapAreaControllerRoute`bir alandaki denetleyiciler için geleneksel bir rota ekler.
* `MapControllerRoute`denetleyiciler için geleneksel bir rota ekler.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Denetleyici eylem adlarından async soneki kaldırma

Core 3.0ASP.NETde, ASP.NET Core MVC denetleyici eylem adlarından `Async` soneki kaldırır. Hem yönlendirme hem de bağlantı oluşturma bu yeni varsayılandan etkilenir. Örneğin:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Önce ASP.NET Core 3.0:

* Önceki eyleme *Ürünler/ListAsync* rotasından erişilebilir.
* Bağlantı oluşturma `Async` sonek belirterek gerekli. Örneğin:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

ASP.NET Core 3.0 olarak:

* Önceki eyleme *Ürünler/Liste* rotasından erişilebilir.
* Bağlantı oluşturma, sonek belirtilmesi `Async` gerektirmez. Örneğin:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Bu değişiklik öznitelik kullanılarak [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) belirtilen adları etkilemez. Varsayılan davranış aşağıdaki kod ile devre `Startup.ConfigureServices`dışı tutulabilir:

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Bağlantı oluşturma değişiklikleri

[Yönlendirmenin önceki sürümlerindeki farklılıklarla](xref:fundamentals/routing#differences-from-earlier-versions-of-routing)ilgili belgelerde açıklandığı gibi, bağlantı oluşturmada `Url.Link` bazı farklılıklar vardır (örneğin, bağlantı oluşturma ve benzeri API'ler). Bunlar:

* Varsayılan olarak, uç nokta yönlendirme sayılırken, oluşturulan ÜRB'lerde rota parametrelerinin gövdesi mutlaka korunmaz. Bu davranış `IOutboundParameterTransformer` arabirimi ile denetlenebilir.
* Geçersiz bir rota için URI oluşturmak (denetleyici/eylem veya var olmayan sayfa) geçersiz bir URI üretmek yerine uç nokta yönlendirmealtında boş bir dize oluşturur.
* Ortam değerleri (geçerli bağlamdan rota parametreleri) bitiş noktası yönlendirmesi ile bağlantı oluşturmada otomatik olarak kullanılmaz. Önceden, başka bir eyleme (veya sayfaya) bağlantı oluştururken, belirtilmemiş rota değerleri *geçerli* rotalardaki ortam değerlerinden çıkarılırdı. Uç nokta yönlendirme sayılırken, bağlantı oluşturma sırasında tüm rota parametreleri açıkça belirtilmelidir.

### <a name="razor-pages"></a>Razor Pages

Haritalama Razor Sayfalar `UseEndpoints`şimdi içinde yer alır.

Uygulama `MapRazorPages` Jilet Sayfaları kullanıyorsa ekleyin. Endpoint Yönlendirme birçok çerçeve için destek içerdiğinden, Razor Pages ekleme artık kabul edilir.

Aşağıdaki `Startup.Configure` yöntemde, `MapRazorPages` Razor Pages için destek ekler:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Endpoint Yönlendirme olmadan MVC kullanın

Core 3.0 üzerinden `UseMvc` veya `UseMvcWithDefaultRoute` ASP.NET'de MVC kullanmak `Startup.ConfigureServices`için içeriden açık bir katılım gerektirir. Bu gereklidir, çünkü MVC başlatma sırasında yetkilendirmeye ve CORS Middleware'e güvenip güvenemeyeceğini bilmelidir. Uygulama desteklenmeyen bir yapılandırma kullanmaya çalışırsa uyarıda bulunduracak bir çözümleyici sağlanır.

Uygulama eski `IRouter` destek gerektiriyorsa, `EnableEndpointRouting` aşağıdaki yaklaşımlardan herhangi `Startup.ConfigureServices`birini kullanarak devre dışı bırakma:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Sistem durumu denetimleri

Sistem durumu denetimleri, Endpoint Yönlendirme ile *yönlendirici-ware* olarak kullanılabilir.

Endpoint Yönlendirme ile sistem durumu denetimlerini kullanmak için ekleyin. `MapHealthChecks` Yöntem, `MapHealthChecks` `UseHealthChecks`' ' ya benzer bağımsız değişkenleri kabul eder. Over `UseHealthChecks` kullanmanın `MapHealthChecks` avantajı, yetkilendirmeyi uygulayabilme ve eşleşen ilke üzerinde daha fazla ince taneli denetime sahip olmaktır.

Aşağıdaki örnekte, `MapHealthChecks` bir sağlık denetimi bitiş `/healthz`noktası için çağrılır:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder WebHostBuilder değiştirir

Core 3.0 şablonlarının ASP.NET [Genel Ana Bilgisayar'ı](xref:fundamentals/host/generic-host)kullanır. Önceki sürümler [Web Host'u](xref:fundamentals/host/web-host)kullandı. Aşağıdaki kod, Core 3.0 şablonu oluşturulan `Program` ASP.NET sınıfını gösterir:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Aşağıdaki kod, Core 2.2 şablonu `Program` oluşturulan ASP.NET sınıfını gösterir:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>3.0'da kalır ve önceki `webBuilder` kod örneğinde görülen türüdür. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>gelecekte piyasaya sürülecek ve `HostBuilder`değiştirilecek.

En önemli değişiklik `WebHostBuilder` `HostBuilder` bağımlılık [enjeksiyonu (DI)](xref:fundamentals/dependency-injection)olduğunu. Kullanırken, `HostBuilder`yalnızca ''nin `Startup`oluşturucusu içine aşağıdakileri enjekte edebilirsiniz:

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

`HostBuilder` DI kısıtlamaları:

* DI kapsayıcısının yalnızca bir kez oluşturulmasını etkinleştirin.
* Singleton birden çok örnekleri çözme gibi ortaya çıkan nesne yaşam boyu sorunları önler.

Daha fazla bilgi için, [ASP.NET Core 3'te Başlangıç hizmet enjeksiyonundan kaçınma](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/)ya da

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization farklı bir derlemeye taşındı

ASP.NET Core 2.2 `AddAuthorization` ve *microsoft.AspNetCore.Authorization.dll*daha düşük yöntemler:

* Adı değiştirildi. `AddAuthorizationCore`
* *Microsoft.AspNetCore.Authorization.Policy.dll*taşınmıştır.

*Hem Microsoft.AspNetCore.Authorization.dll* hem de *Microsoft.AspNetCore.Authorization.Policy.dll* kullanan uygulamalar etkilenmez.

*Microsoft.AspNetCore.Authorization.Policy.dll* kullanmayan uygulamalar aşağıdakilerden birini yapmalıdır:

* *Microsoft.AspNetCore.Authorization.Policy.dll*adresine başvuru ekleyin. Bu yaklaşım çoğu uygulama için çalışır ve gerekli olan tek şeydir.
* Kullanmaya geç`AddAuthorizationCore`

Daha fazla bilgi için bkz: [Breaking change in) `AddAuthorization(o =>`aşırı yük, farklı bir derlemede #386.](https://github.com/aspnet/Announcements/issues/386)

## <a name="identity-ui"></a>Kimlik UI

core 3.0 ASP.NET için Kimlik Arabirimi güncelleştirmeleri:

* [Microsoft.AspNetCore.Identity.UI](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI)bir paket başvurusu ekleyin.
* Razor Pages kullanmayan uygulamalar aramalıdır. `MapRazorPages` Bu belgedeki [Razor Pages'e](#razor-pages) bakın.
* Bootstrap 4 varsayılan UI çerçevesidir. Varsayılanı `IdentityUIFrameworkVersion` değiştirmek için bir proje özelliği ayarlayın. Daha fazla bilgi için [bu GitHub duyurusuna](https://github.com/aspnet/Announcements/issues/380)bakın.

## SignalR

SignalR JavaScript istemcisi `@aspnet/signalr` ' `@microsoft/signalr`den ' e değiştirildi Bu değişikliğe tepki vermek için *package.json* `require` dosyalarındaki, deyimlerde `import` ve ECMAScript ifadelerindeki başvuruları değiştirin.

### <a name="systemtextjson-is-the-default-protocol"></a>System.Text.Json varsayılan protokoldür

`System.Text.Json`artık hem istemci hem de sunucu tarafından kullanılan varsayılan Hub protokolüdür.

In `Startup.ConfigureServices`, `AddJsonProtocol` serializer seçeneklerini ayarlamak için arayın.

**Sunucu:**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Istemci:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Newtonsoft.Json'a geç

[System.Text.Json'da desteklenmeyen Newtonsoft.Json özelliklerini](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)kullanıyorsanız, `Newtonsoft.Json`. Bkz. Bu makalenin daha önceki [bir SignalR ASP.NET Core 3.0 projesinde Newtonsoft.Json](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) kullanın.

## <a name="redis-distributed-caches"></a>Redis dağıtılan önbellekler

[Microsoft.Extensions.Caching.Redis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Redis) paketi ASP.NET Core 3.0 veya sonraki uygulamalar için kullanılamaz. Paket başvurusunu [Microsoft.Extensions.Caching.StackExchangeRedis ile değiştirin.](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis) Daha fazla bilgi için bkz. <xref:performance/caching/distributed>.

## <a name="opt-in-to-runtime-compilation"></a>Çalışma zamanı derlemesine katılmayı seçme

Core 3.0ASP.NET önce, görünümlerin çalışma zamanı derlemesi çerçevenin örtük bir özelliğiydi. Çalışma zamanı derlemesi, görünümlerin oluşturma zamanı derlemesini tamamlar. Bu çerçeve, tüm uygulamayı yeniden oluşturmak zorunda kalmadan, dosyalar değiştirildiğinde Razor görünümleri ve sayfaları *(.cshtml* dosyaları) derlemek için izin verir. Bu özellik, IDE'de hızlı bir değişiklik yapma ve değişiklikleri görüntülemek için tarayıcıyı yenileme senaryosunu destekler.

Core 3.0ASP.NET, çalışma zamanı derlemesi bir kabul senaryosudur. Yapı zamanı derlemesi, varsayılan olarak etkinleştirilen görünüm derlemesi için tek mekanizmadır. Çalışma süresi, *.cshtml* dosyalarındaki değişiklikleri algıladığında projeyi yeniden oluşturmak için Visual Studio veya Visual Studio Code'daki [dotnet-watch'a](xref:tutorials/dotnet-watch) dayanır. Visual Studio'da, çalıştırılan projedeki *.cs*, *.cshtml*veya *.razor* dosyalarındaki değişiklikler<kbd>(Ctrl+F5),</kbd>ancak debugged değil<kbd>(F5),</kbd>projenin yeniden derlenmesini tetikler.

ASP.NET Core 3.0 projenizde çalışma zamanı derlemesini etkinleştirmek için:

1. [Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation) NuGet paketini yükleyin.
1. Güncelleme `Startup.ConfigureServices` aramak `AddRazorRuntimeCompilation`için:

    Core MVCASP.NET için aşağıdaki kodu kullanın:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Core Razor Sayfalarını ASP.NET için aşağıdaki kodu kullanın:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
Aşağıdaki https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation örnek, Geliştirme ortamlarında koşullu olarak çalışma zamanı derlemesini etkinleştirme örneğini gösterir.

Razor dosya derlemesi hakkında <xref:mvc/views/view-compilation>daha fazla bilgi için bkz.

## <a name="migrate-libraries-via-multi-targeting"></a>Kütüphaneleri çok hedefleme yoluyla geçirin

Kitaplıkların genellikle ASP.NET Core'un birden çok versiyonunu desteklemesi gerekir. ASP.NET Core'un önceki sürümlerine karşı derlenen çoğu kitaplık sorunsuz çalışmaya devam etmelidir. Aşağıdaki koşullar, uygulamanın çapraz derlemesi ni gerektirir:

* Kitaplık, ikili [kesme değişikliği](#breaking-api-changes)olan bir özelliğe dayanır.
* Kütüphane, ASP.NET Core 3.0'daki yeni özelliklerden yararlanmak istiyor. 

Örneğin:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Core `#ifdefs` 3.0'a özgü API'ASP.NET etkinleştirmek için kullanın:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

Sınıf kitaplığında ASP.NET Çekirdek API'lerini <xref:fundamentals/target-aspnetcore>kullanma hakkında daha fazla bilgi için bkz.

## <a name="miscellaneous-changes"></a>Çeşitli değişiklikler

.NET Core 3.0'daki doğrulama sistemi ve daha sonra nullable olmayan parametreleri `[Required]` veya bağlı özellikleri bir özniteliğe sahipmiş gibi davranır. Daha fazla bilgi için [bkz.](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute)

### <a name="publish"></a>Yayımlama

Proje dizinindeki *bin* ve *obj* klasörlerini silin.

## <a name="testserver"></a>TestSunucusu

Doğrudan Genel <xref:Microsoft.AspNetCore.TestHost.TestServer> [Ana Bilgisayar](xref:fundamentals/host/web-host)ile kullanan `TestServer` uygulamalar <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> için, bir in'i <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A>oluşturun:

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>API değişikliklerini kesme

Son dakika değişikliklerini gözden geçirin:

* [ASP.NET Core 3.0 sürümündeki son dakika değişikliklerinin tam listesi](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Antiforgery, CORS, Diagnostics, MVC ve Yönlendirme API değişiklikleri breaking.](https://github.com/aspnet/Announcements/issues/387) Bu liste, uyumluluk anahtarları için kesme değişiklikleri içerir.
* .NET Core, ASP.NET Core ve Entity Framework Core genelinde 2,2'den [3'e 2,0'a](/dotnet/core/compatibility/2.2-3.0)son dakika değişikliklerinin özeti için bkz.

## <a name="net-core-30-on-azure-app-service"></a>Azure Uygulama Hizmetinde .NET Core 3.0

.NET Core'un Azure Uygulama Hizmeti'ne sunulması yla ilgili ilerleme kaydetmek [için, App Service](https://aspnetcoreon.azurewebsites.net/) web sitesindeki resmi .NET Core web sitesine bakın. .NET Core 3.0 Azure Uygulama Hizmeti'nde kullanılabilir olana kadar, [Azure App Service için ASP.NET Core önizleme sürümünde yönergeleri](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service)izleyin.
